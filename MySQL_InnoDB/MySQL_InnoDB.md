# 深入理解MySqL
---
1. MySql常用数据引擎
   myiasm和innodb的区别：
   - 是否支持行锁：innodb支持行锁，myiasm只支持表锁。
   - 是否支持事务和崩溃后安全恢复：innodb支持事务，由于有事物的安全机制，所以方便安全恢复。
   - 是否支持外键：innodb支持
   - 是否支持MVCC：只有innodb在可重复读和读已提交下支持MVCC机制
   - 索引不同：innodb是聚簇索引，myisam是非聚簇索引
2. MVCC多版本并发
   MVCC是一种提高并发的技术。早先的数据库只有读读之间可以并发，读写、写读、写写都要阻塞。引入MVCC之后，只有写写之间互相阻塞，其他三种操作都可以并行，大幅提高了innodb的并发能力。**在innoDB是在undolog中实现的，通过undolog找回数据的历史版本**。找回的历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以回滚的时候覆盖数据页上的数据。**在innodb内部，会记录一个全局的活跃读写事务数组，主要用来判断事务的可见性**。
   - MVCC并没有统一的标准和实现机制，不同的数据库不尽相同，典型的有乐观并发控制和悲观并发控制。
   - MVCC可以理解为行锁的变种，但是在多数情况下避免了加锁，因此开销更低。
   - MVCC只在RC,RR两个级别下工作。RU总是读取最新的数据行，而不是符合当前事务版本的数据行。而Serializeable对所有读取行都加锁。
3. **readView：**
   - 主要用来做可见性的判断。可以理解为本事务不可见的当前其他活跃事务。
   - **对于readView快照的生成时机不同，造成了RC和RR两种隔离级别可见性的不同。** 1. innodb中RR级别，事务在begin/start之后的第一条select读操作后，会创建一个快照，将当前系统中活跃的其他事务记录起来。2. RC级别，事务中每条select都会创建一个快照。
4. undo-log
   - ubdolog是innodb MVCC事务特性的重要组成部分。当记录做了变更操作就会产生undo日志。
   - undo日志中存储的是老版本数据，当一个旧的事务要读取数据时，为了能读取到老版本数据，需要顺着undo链找到满足其可见性的记录。**如果版本链很长，比较耗时**
   - 大多数数据变更操作insert/delect/update，insert事务提交前只对当前事务可见，因此产生的undo可以在事务提交后直接删除(因为事务对插入的信息的过去没有可见性需求，拿到当前值即可)。**对于update和delect需要多版本维护，这两种操作被归为一类-update-undo**：
   - - ==insert== undo log: 事务对insert新纪录时产生的undolog，**只在事务回滚时候需要，并且提交之后可以立即丢弃。** 
   - - ==update== undo log: 不仅在事务回滚是需要，一致性读也需要，不能随便删除。只有当数据库所使用的快照中不在设计该日志，会被purge线程删除。
5. innodb存储引擎在数据库每行数据的后面，添加三个字段：
   - ROW_ID：如果没有主键或没有唯一id，不可以构建聚簇索引的时候，系统默认rowid作为主键索引。
   - TRX_ID：表示最近一次对本记录做修改(insert/update)的事务标识符。==即最后一次修改本行记录的事务id==。
   - ROLL_PTR：写入回滚段的 `undo log` 的记录（日志记录的记录）。如果一行纪录被更新，undolog包含**重建该行记录更新之前的记录**，的所有信息。
6. 聚簇索引和非聚簇索引
   - innoDB是聚簇索引：B+树的叶子节点包含的是主键以及主键对应的数据，做查询时候可以通过索引直接找到数据所在的页。索引都作为辅助索引，辅助索引的data域存储相应记录主键的值⽽不是地址，这也是和MyISAM不同的地⽅。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引频繁分裂。
   - myisam是非聚簇索引：B+树的叶子节点是主键和数据的地址，需要根据地址找到数据的位置。
7. 非聚簇索引一定回回表查询？
   不一定，这涉及到查询语句所要求的字段是否全部命中索引，如果全部命中了索引，那么就不必回表查询。我查的只是键的话就不用。
   **==覆盖索引==**
   如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。
8. 联合索引是什么？
   联合索引就是多个字段组成的索引。使用索引的时候遵循最左原则，按照当初建立索引的顺序，从左往右查，一旦对不上就没法用了。当然也不是绝对的..sql优化器也可能使用也可能不使用。
9.  可见性比较算法
   - 1 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.
   - 2 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。
   - 3 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。
   - 4 从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。
   - 将该可见行的值返回。
---
10. 当前读和快照读
   - mysql的innodb默认事务隔离级别是RR，通过**行锁+MVCC**一起实现的，不仅可以保证可重复读，还可以**部分防止幻读**，而非完全防止。
11. 为什么是部分防止幻读，而不是完全防止
    - **如果事务B在事务A中执行，insert了一条数据并提交，事务A再次查询，虽然读取的是undo中的旧版本数据(部分防止幻读)，但是事务A中执行update或delete都是可以的。**==mvcc解决了select的幻读(读的是快照)，但是对于update和delete是当前读，虽然select读不到但是这两个指令还是可以更新和删除。==
    - 在innodb中的操作可分为**当前读和快照读。** 1.快照读(select，MVCC不加锁)：在查阅了一些资料后发现在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)。2. 当前读-(insert/update/delect)加锁(select ... lock in share mode/select ... for update） ==加上for update 在默认隔离级别下会有next-key，可以说是解决了幻读的问题==
    - RR级别下，快照读是通过MVCC和undolog实现的，当前读是通过record lock和gap lock来实现的。**快照都的情况下没有避免幻读，当前读避免了幻读和不可重复读。**
  
**到底什么是幻读：** mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。
**到底如何解决幻读**
- 使用串行化读的隔离级别
- MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)
---
12.  大表优化
    当MySQL但表记录数过大时，数据库性能下降：
    **限定数据的的范围：** 务必禁止不带任何限制数据范围调剂的查询语句。
    **读/写分离：** 经典数据库拆分方案，主库负责写、从库负责读。
    **垂直分区：** 根据数据库根据数据表的相关性进行拆分。简单的来说垂直拆分是指数据列表的拆分，把一张列比较多的表拆分为多个表。
    缺点：主键出现冗余，会造成join操作。
    优点： 列数据变小，查询时减少读取的block数，简化表结构，便于维护。
    **水平分区：** 保持数据表结构不变，通过某种策略数据分片。一般使用中间件---mycat
    **分库分表I的如何处理：** 分布式id生成系统
---
13. 一条SQL语句在MYsql中如何执行的
    1. 客户端发送sql给数据库服务器
    2. 优化器进行解析，优化，确定执行方案
    3. 数据库引擎根据优化器生成的流程执行，得到结果
    4. 结果返回给客户端

14. 如何更新语句？
    MySQL 自带的日志模块式 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：
    - 查询数据
    - 修改数据，保存在redolog，进入prepare状态，高素质星期可以提交
    - 执行器通知记录binlog完，redolog在提交
    - 更新完成
15. 为什么使用两个日志模块？
    因为redolog是innodb自带的，这会导致丢失安全问题(宕机后日志全丢)，binlog只能归档。
16. 为什么二段提交。为什么 redo log 要引入 prepare 预提交状态？
    - **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
    - **先写 binlog，然后写 redo log，假设写完了 binlog**，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。
    **采用redolog 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。**
    有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：
    - 判断 redo log 是否完整，如果判断是完整的，就立即提交。
    - 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。


---
### Redis
1. 项目中缓存是如何使用的？为何使用？
   - 缓存用处 高性能高并发。1. 对于某些耗时但不常改变的操作，扔到缓存里。2. 大量请求打向数据库，一定会完蛋。要打到缓存中。
2. redis和memcached有什么区别？
   - redis有更丰富的数据结构
   - redis支持持久化
   - redis是单线程的(6.0变成多线程但我没看过)
   - redis支持原生集群模式。cluster
3. redis单线程为什么这么快？
   redis使用事件处理器，核心就是IO多路复用。IO多路复用程序会监听多个socket，产生时间的socket放入队列，每次取出一个执行。
   - 纯内存操作
   - 核心是基于非阻塞的IO多路复用机制
   - 单线程避免了频繁的线程上下文切换带来的损耗。
   - SDS结构，不过我对于这个结构没有细致了解过。
4. IO多路复用 select/poll/epoll的区别
   redis的IO多路复用是基于操作系统的，所以linux下：
   select：会不停轮询监听所有socket集合，并且每次调用都要把所有集合从用户态拷贝到内核态；
   poll几乎和select一样，好像只是集合结构变了。
   epoll：与前两者不同，会有一个线程监控socket，激活后会把线程放到队列里面然后通知epoll。epoll醒来的时候只要扫描一下等待队列是否是空的就行了。
5. redis的过期策略有哪些
   - 定时删除：指定一段时间，随机抽一堆key检查过期的删掉。
   - 惰性删除：获取到key的时候检查是都过期，国企删掉。
6. redis内存太太策略
   - allkeys-lru/radom/ttl：所有key中移除最近最久没使用/随机/最早过期
   - volatile-lru/random/tll：已过期的key中
7. 如何保证redis的高并发和高可用？
   集群/主从架构/哨兵
8. redis的持久化方式有哪几种？
   持久化主要是为了做灾难恢复，容灾备份。
   持久化是fork新的进程，对持久化本身没有影响。
   - AOF：末尾追加。追加间隔可以自己选，系统控制，每秒，每条指令。
   - RDB：快照。对数据进行周期性的持久化。
   - 二合一：由于AOF比较大，RDB比较适合冷备份，所以结合二者优点，我忘记是几号版本加进去的了。
   **==DB优缺点：==**
   - RDB会生成多个数据文件，表示每个时刻中redis的数据，非常适合做定期冷备份。
   - RDB对redis的影响非常小，主进程只需要fork一个子进程。  **RDB在fork子进程的时候，如果数据文件过大可能回暂停几毫秒**
   - 相对AOF来说，基于RDB数据文件来重启和恢复redis进程更快
   - RDB不适合做及时备份
   **==AOF的优缺点==**
   - AOF及时性更好
   - AOF写入性能更高
   - AOF日志文件即使过大的时候出现后台重写，也不会影响客户端。 因为AOF会指令压缩，创建出来一个最小日志。
   - AOP一般比RDB更大
   - AOF开启后一般会设置每秒持久化，所以OPS会更低
**所以二者如何选择？**
   二合一！
9. redis集群的工作原理？
    过去redis实现集群需要借助中间件，例如codis，好像是豌豆荚开团队搞得。现在redis支持原生cluster
    **redis cluster：**
    - 自动将数据进行分片，每个master上放一部分数据
    - 提供内置的高可用支持，部分master不可用时，还可以继续工作。
    **节点间的内部通信机制**
    - 基本原理：集群元数据的维护有两种：集中式，**gossip协议。redis使用后者。 所有节点都==持有一份元数据==，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。**
    gossip 好处在于，元数据的**更新比较分散**，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，**降低了压力**；不好在于，元数据的**更新有延时**，可能导致集群中的一些操作会有一些滞后。
    **一致性哈希算法**
    - 一个虚拟的环，环上面有物理机。通过hash映射到换上，然后顺时针找到离他最近的物理机。这样可以克服哈希扩容时需要rehash的问题，即便一个节点宕机也只会损失一小部分数据。但是可能会造成数据倾斜。于是又引入了虚拟节点，只要虚拟节点够多，理论上就是均匀连续的，负载均衡的。
    **redis cluster的哈希槽算法**
    - redis集群有固定的16384个哈希槽，每个master会持有部分slot，宕机任何一台及其对其他机器无影响。
10. redis集群的高可用性与主备切换原理
    基本就是哨兵实现的
    - 判断宕机节点： 如果节点认为另一个节点宕机，那么就是主观宕机。如果多个节点都认为另一个节点宕机，客观宕机。
    - 从节点过滤： 宕机的主节点，从所有的从节点中选一个换成主节点。
    - 从节点选举：根据自己对主节点复制数据的offset，设置一个选举时间。offset越大越容易被选到。
11. redis的缓存雪崩？
    一时间大量缓存过期，大量请求直接落库，服务器宕机。
    解决方案： 
    - 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 
    - 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
    - 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
12. 缓存穿透
    大量请求不在缓存中，绕过redis直接落库。
    解决方案：使用布隆过滤器。从结果上上看是不存在的一定不存在，存在的不一定存在。
13. 缓存击穿
    热点key，访问频繁，高并发请求。当这个key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库。
    解决方案：热点数据永不过期；redis实现互斥锁，等待第一个请求构建玩缓存之后在释放锁。
14. 如何保证缓存与数据库的双写一致
    经典缓存+数据库读写模式：读的时候，先读缓存，缓存没有的话，读数据库，取出数据放入缓存。 **更新的时候，先更新数据库，才删除缓存。**==这会造成缓存里面有旧数据==
    解决方案：先删除缓存，在更新数据库。==这样会造成缓存和数据库中内容不一致问题==。
    
    如果上亿流量高并发场景缓存出现还是有问题怎么办：

15. redis的事务
    watch和mutil CAS乐观锁实现。
    某个时刻，多个系统实例都去更新某个key。可以基于zookeeper实现分布式锁。每个系统通过zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。
    

