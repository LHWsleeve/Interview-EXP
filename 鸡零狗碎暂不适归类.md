鸡零狗碎，偶尔突然看到的一些好的回答，不适合放入大板块
---
1. IOC怎么讲？
从设计原则中的依赖倒置原则开始讲。比如原先设计一辆汽车的时候，我们可能是先设计轮子->地盘->车壳这么一个依赖关系。但是这种依赖关系会存在一个问题就是，假设我要把原来写死的轮子尺寸改成动态传值，那么每一个上层类都需要提供一个size入口，非常麻烦，几乎是不可维护的。
所以我们需要**控制反转(IOC)**，即上层控制下层，而不是下层控制上层,这是依赖倒置原则的具体实现方式。
在Spring中我们使用DI来实现控制反转。所谓的依赖注入就是把底层类作为参数传入上层类，实现上层对下层一种控制。
回到刚才的车子假设，**如果使用构造方法传递的依赖注入方式**：轮子<-地盘<-车壳。如果此时需要改变轮胎尺寸，只需要在最上层改变传参大小即可，底层不需要任何变化。。。当然Spring里面还有**set注入和接口注入**。
而Spring中的IOC控制反转容器就是我们初始化类代码的地方。因为我们使用依赖注入，不可避免地会new一大堆的东西出来。IOC容器就解决了这个问题，容器可以自动对代码初始化，由容器管理bean生命周期。
IOC容器第二个好处就是，创建实例的时候程序员不需要在乎细节，自己寻找注入的对想进行解决循环依赖，并且注入实例。
---
2. 论述一下循环依赖
   假设是A实例化的过程中注入B，而B实例化的过程中需要注入A。并且不考虑无法解决循环依赖的情况。
 Spring在创建Bean的时候是按照自然排序来的，所以按照代码顺序进行创建。
 创建的过程就是调用`getBean()`方法，包含两个含义：
    - 创建一个新的bean
    - 从一级缓存(单例池)中取出一个bean
  
首先调用`getSinglton(a)`方法，这个方法会调用`getSingleton(beanName, true)`：这个方法就是根据方法名区缓存中尝试获取bean(三个缓存)。如果缓存中不存在，那么进入creatBean流程，并且最后一定会把Bean放入单例池中。

完成Bean实例化后，属性注入之前Spring将Bean包装成一个工厂添加进三级缓存中(`addSingletonFactory`,为循环依赖和AOP做准备)，这个工厂的作用就是`getObject`得到一个提前暴露的对象。
当A完成实例化并且放入三级缓存后，对A进行属性注入，在注入时发现A依赖了B，那么这时候Spring又回去getBean(b)，然后反射调用`setter`方法完成属性注入。
对B进行属性注入时需要注入A，此时又要调用getBean(A)，这时候又回到之前的流程，只不过此时三级缓存中存在刚才生成的A的实例，此时可以通过`getEarlyBeanReference`方法提前暴露出区A的对象`earlySingletonObjects`，在不存在AOP的情况下直接就返回这个对象了。
然后后续继续属性注入，然后删除前面的二级缓存和三级缓存，并且Bean放入一级缓存。

**如果有AOP存在**
在三级缓存的工厂中，我们对A进行了AOP代理的话，那么此时`getEarlyBeanReference`将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着**B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象**。

**Spring是如何解决的循环依赖？**
**答**：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（`singletonObjects`）,二级缓存为早期曝光对象`earlySingletonObjects`，三级缓存为早期曝光对象工厂（`singletonFactories`）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用`getBean(a)`来获取需要的依赖，此时的`getBean(a)`会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的`getObject`方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！

**为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？**
**答：** 如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过`AnnotationAwareAspectJAutoProxyCreator`这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。

