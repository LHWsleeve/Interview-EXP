<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [😀 代码整洁之道](#代码整洁之道)
  - [😀 第二章 有意义的命名](#第二章-有意义的命名)
  - [😀 第三章 函数](#第三章-函数)

<!-- /code_chunk_output -->


## 代码整洁之道
***
### 第二章 有意义的命名
1. 类名应该使用名词或名词短语，方法应该使用动词
2. 不要用“双关”，同样的方法名，用在两个相似的地方。例如向DB插入一条数据使用add(),像集合插入一个元素也使用add()，本质上其实是不同的。
3. 命名不要又臭又长且相似。
> *这种类名我看到过很多，我非常想掐死命名的人。*

### 第三章 函数
1. 函数要尽可能地短小。
> *yysy,这个我无法理解。书中将三五行代码拆成一个命名精准的方法，这将导致整个文件中四处都是简短的方法，观感上很烦。甚至将if、else中的代码块再包一层，让代码块只占一行。作者提出一个想法：代码的缩进层级不多于一层或两层。*
2. 一个函数应当只做一件事
> *这个思想我认可。方法名实际上也只能代表一件事，通过方法名我应该能明确知道内部做了什么。如何做到这一点？作者给了一个想法：方法是否能再拆除一个方法。*
3. 函数中的操作需要在同一个抽象层级
> 很难理解这个抽象层级。大体上约细粒度，越精确的行为就是越低抽象级。

作者提出：所有的方法中的内容应该是同一个抽象层级的。方法及方法内的方法，应该符合*总-分-再分*的这种模式。
> 就我个人而言，我更喜欢将总-分-再分，写在一个方法中当成一个模块，而非再抽象层级上进行划分。我不确定那种更合适，不过作者的方法会更灵活，但是书写更繁琐，大量的冗余。我的方式随着业务的增加，模块越大，阅读起来可能会越痛苦。---**不过我发现实际上优秀的源码，都会采用作者的方式。**

4. 关于switch，作者反对无脑的往里面做分支。转而采用逆向思维，不是单纯的在switch中写代码，而是将switch分支中的条件使用抽象工厂埋藏起来。
> 这种方式虽然没有减少代码量，也没有看起来更好看，实际上还增加了复杂度。但是对日后的扩展有很大的好处，抽象工厂类可以直接增加具体的类型。*yysy，不是很懂...先看GOF会不会好理解一点*

5.  使用具有描述性的名称
> 作者表示，方法名可以长
6. 函数参数越少越好。作者认为最好的参数数量是0，如非必要无论如何不能多于3及以上。
``` txt
6.1 单参数的函数形式
传入单个参数一般是三种形式：
a. 对入参进行判断或校验
b. 对入参进行操作并输出
c. 是一种事件(event)，有入参无出参,使用该参数修改系统状态
```  
> 在这里作者提出了一个想法：所有的单参数都应该遵循以上三种类型。对于常见的“转换”逻辑，转换结果就应该体现为返回值，而不是很多人喜欢的，将一个DTO扔到方法里，一通转换最后修改了入参DTO中的值。**如果严格按照作者单参数用法来看，我对于进房接口的划分处理就是💩，我新建了一个context作为上下文，在整个代码逻辑中填充context的所有字段，并且没有出参**

``` txt
6.2 标识参数(布尔值参数)
```  
 作者认为，在入参中写布尔值是及其SB的做法。对于所有需要布尔值作为标识的函数，都应该拆成两个，针对不同情况去执行方法。

 > 作者对于布尔值入参的态度...我不予评价。不过我在日常工作中确实也极少使用布尔值入参。
 ``` txt
6.2 双参数函数
``` 
作者对双参数的函数态度尚可。肯定有存在的必要，但是大部分情况下还是鼓励能改成单参，就单参。
``` txt
6.3 三参数函数
``` 
> 作者没怎么评价三参数函数...但是举的例子我愣是没看懂，不像java啊....
``` txt
6.4 动词和关键字
函数名和参数最好可以形成动名词的联动，例如write(name)
``` 
> 这点我很认同，也很符合人性...一眼就能知道这个函数是干什么的。

**另外，关于本节，作者还提了：对于大量参数，应该使用参数对象进行封装；对于可变参数(...arg)，应该当成一个List参数来看待**