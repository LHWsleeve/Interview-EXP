
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [代码整洁之道](#代码整洁之道)
  - [第二章 有意义的命名](#第二章-有意义的命名)
  - [第三章 函数](#第三章-函数)

<!-- /code_chunk_output -->


## 代码整洁之道
***
### 第二章 有意义的命名
1. 类名应该使用名词或名词短语，方法应该使用动词
2. 不要用“双关”，同样的方法名，用在两个相似的地方。例如向DB插入一条数据使用add(),像集合插入一个元素也使用add()，本质上其实是不同的。
3. 命名不要又臭又长且相似。
> *这种类名我看到过很多，我非常想掐死命名的人。*

### 第三章 函数
1. 函数要尽可能地短小。
> *yysy,这个我无法理解。书中将三五行代码拆成一个命名精准的方法，这将导致整个文件中四处都是简短的方法，观感上很烦。甚至将if、else中的代码块再包一层，让代码块只占一行。作者提出一个想法：代码的缩进层级不多于一层或两层。*
2. 一个函数应当只做一件事
> *这个思想我认可。方法名实际上也只能代表一件事，通过方法名我应该能明确知道内部做了什么。如何做到这一点？作者给了一个想法：方法是否能再拆除一个方法。*
3. 函数中的操作需要在同一个抽象层级
> 很难理解这个抽象层级。大体上约细粒度，越精确的行为就是越低抽象级。

作者提出：所有的方法中的内容应该是同一个抽象层级的。方法及方法内的方法，应该符合*总-分-再分*的这种模式。
> 就我个人而言，我更喜欢将总-分-再分，写在一个方法中当成一个模块，而非再抽象层级上进行划分。我不确定那种更合适，不过作者的方法会更灵活，但是书写更繁琐，大量的冗余。我的方式随着业务的增加，模块越大，阅读起来可能会越痛苦。---**不过我发现实际上优秀的源码，都会采用作者的方式。**

4. 关于switch，作者反对无脑的往里面做分支。转而采用逆向思维，不是单纯的在switch中写代码，而是将switch分支中的条件使用抽象工厂埋藏起来。
> 这种方式虽然没有减少代码量，也没有看起来更好看，实际上还增加了复杂度。但是对日后的扩展有很大的好处，抽象工厂类可以直接增加具体的类型。*yysy，不是很懂...先看GOF会不会好理解一点*

5.  使用具有描述性的名称
> 作者表示，方法名可以长
6. 函数参数越少越好。作者认为最好的参数数量是0，如非必要无论如何不能多于3及以上。
``` txt
6.1 单参数的函数形式
传入单个参数一般是三种形式：
a. 对入参进行判断或校验
b. 对入参进行操作并输出
c. 是一种事件(event)，有入参无出参,使用该参数修改系统状态
```  
> 在这里作者提出了一个想法：所有的单参数都应该遵循以上三种类型。对于常见的“转换”逻辑，转换结果就应该体现为返回值，而不是很多人喜欢的，将一个DTO扔到方法里，一通转换最后修改了入参DTO中的值。**如果严格按照作者单参数用法来看，我对于进房接口的划分处理就是💩，我新建了一个context作为上下文，在整个代码逻辑中填充context的所有字段，并且没有出参**

``` txt
6.2 标识参数(布尔值参数)
```  
 作者认为，在入参中写布尔值是及其SB的做法。对于所有需要布尔值作为标识的函数，都应该拆成两个，针对不同情况去执行方法。

 > 作者对于布尔值入参的态度...我不予评价。不过我在日常工作中确实也极少使用布尔值入参。
 ``` txt
6.2 双参数函数
``` 
作者对双参数的函数态度尚可。肯定有存在的必要，但是大部分情况下还是鼓励能改成单参，就单参。
``` txt
6.3 三参数函数
``` 
> 作者没怎么评价三参数函数...但是举的例子我愣是没看懂，不像java啊....
``` txt
6.4 动词和关键字
函数名和参数最好可以形成动名词的联动，例如write(name)
``` 
> 这点我很认同，也很符合人性...一眼就能知道这个函数是干什么的。

另外，关于3.6本节，作者还提了：对于大量参数，应该使用参数对象进行封装；对于可变参数(...arg)，应该当成一个List参数来看待。

7. 无副作用，函数应该只做一件事，并且方法命中也应该明确的体现该方法制作了一件事。
>个人非常认同，但是coding的过程总是触犯上述错误。

作者*输出参数*有想法：例如我常常写的liveRoomInfo(xxx, xxx)此类方法。本意是对入参进行修改，并且修改入参的属性状态。作者认为liveRoomInfo.xxx()对于这类行为更合适。更"**面向对象**"。
8. 作者认为函数要么，做什么事，要么回答什么事，二者不可兼得。例如，设置属性的方法，和判断属性的方法应该是两个。不应该在一个方法中做，设置某个属性成功，则返回true，如果不存在这个属性返回fasle，这种行为。
> 我认为这个说法是正确的，但是在coding过程中很容易忽略。判断一件事，和做一件事，应该显然是两个方法。
9. 关于异常处理，作者提出以下想法
```txt
1. 不应该使用自定义的错误码来代替异常。这样可能会有一大堆if嵌套 
2. 抽离try/cactch中的代码，封装成单独方法，对外抛异常，由catch接收
3. 如果存在try内容，那么应该是这个函数的第一行开始，并且在catch/finally代码块中不做任何与错误无关的事情。
4. ErrorEnum.java，类似的状态码枚举类会被多个应用所引入。当枚举类修改时候，下游需要重新编译和部署。而使用异常代替错误码，新的异常可以从异常类派生出来，无需重新编译。
```
> 事实上，对于3.try/catch在工作中常常被用来做正常业务逻辑的万能兜底，而非是针对错误的处理（但好像兜底理解为针对错误的处理也没有问题）。对于4.不理解重新编译和部署是个什么意思...发线上不是肯定重新部署的吗？

### 第四章 注释
开宗明义，作者认为：**注释是一种代码上的失败**。
所以...多余的也不用打了。作者认为是shit。
### 第五章 格式
1. 第一小节没什么新鲜的，主要思想还是一个类的代码行数尽量小，中位数应该不高于100行。

2. 垂直方向上的格式。这部分作者阐述了一下几个方面的编码规则，个人认为基本都算常识吧
```txt
1.垂直方向上要用空行对方法或表达式进行分割，不要全部堆在一起。（不过我喜欢把注入的那一串玩意全部紧挨着）
2. 垂直方向上要靠近。这个原则是针对实体变量活着DTO之流，申明的时候不要全是注释...鸡贼shit，看起来还累脖子
3. 垂直距离/垂直顺序。这部分主要宗旨就是，调用方和被调用方自顶向下编写，相关性越强的越靠近。如果出现重载方法，适合全部放一起(我觉得很丑，但是确实更方便)。
```
> 对于垂直这部分没什么好说的，总的来说都是我coding过程中或者idea自动生成方法的过程中默认遵循的规则。

3. 横向格式
> 这部分内容很多东西，针对现有的idea来讲都是扯淡。格式化一下就全部ok了。不过作者提到的两点值得一看。
> a. 空格不应该无脑使用，最好根据运算符优先级使用。例如c = a\*a - b\*d。显然乘法优先级高于加减，所以紧密挨着，而加减和等于有空格
> b. 对于某些可以压缩的单行循环体，例如while(a){exceute();}。很容易被忽视，应该在下一行打一个';'，引起重视，否则容易漏掉。

### 第六章 对象和数据结构
1. 数据抽象。作者认为不应该滥用getter和setter，应该使用接口和接口中的方法获得数据，从而隐藏具体的数据细节。
> 这里我大概的理解是，对外提供的方法也好、接口也好都不应当过于具体，应该以业务层的抽象形式对外透出。我也对private变量，却提供public读写方法感到奇怪...不过现有的贫血模型形式的POJO决定了必须要这么做。可能DDD架构，对于赋值和取值器要更谨慎。
2. 数据、对象的反对称程序。
> 这里作者说的听拗口，实际上就是数据对应"过程式编程"，简单的讲就是在一个方法中继续加屎山。对象对应"面向对象编程"，具体来说就是接口新加一个函数。
>过程式编程适合不改动数据结构的前提下添加新的函数，面向对象编程适合在不改动现有函数的情况下添加新类。
>反过来说，过程式编程难以添加新的数据结构，因且必须修改所有函数，面向对象编程不适合添加新函数，因为必须修改所有类。前者是一个类内的，后者是多态下多个类的。
> 阅读这一部分的时候，总是会迷惑。主要是因为日常工作中没有人绝对的面向对象或面向过程，日常就是一起使用。
3. demeter法则，模块不应了解他所操作对象的内部情形：**对象隐藏数据，暴露操作。数据结构获取数据，不包含操作和行为** 
```txt
>具体来讲C对象中的f方法只能调用以下对象的方法：
> 1.C  
> 2.由f创建的对象
> 3.作为入参传递给f的对象
> 4.C本身持有的实体对象

其中作者还举了几个例子，比如 c.geta().getb().getc()。这中c得到a对象，然后调用a中的b得到c，然后调用c方法得到一个返回值，是十分丑陋的方法。
违反了上述定律，他调用了geta()的函数，又调用了前者返回值的getb()函数.....实际上除了geta()之外的其他方法都不是C的方法，
```
> 对第六章我看的还是很蒙的。对于数据结构和对象没有一个准确的定义，大体上我这么认为：java开发过程中我们所使用的POJO等都是可以定义为数据结构，而具体的component活着service、interface等都是对象。作者有一个观点我不确定是否应该遵循：“**对象就应该做点什么。**”这句话的意思，不应该调用对象的getxxx()方法获取什么，此类方法应当是对象内部自己doSomething()使用,而非暴露给外层，对象应该doxxx()进行行为或操作。getxxx()应该是直接从数据结构类型的POJO中获取数据的。
> 按照这个思想来看，我日常在component中写的各种getxxx()就是shit。
> 我不确定作者的想法是否正确，或者我的理解是否正确。不过日后开发工作我会尽量遵循这个原则，不再对**对象**乱用getxxx()方法。

4. 数据传输对象(DTO)
> 普通的DTO没什么好讲的。
> 作者说的active record让我比较好奇，大体浏览了一下。一种领域模型，除了包含普通的DTO性质外，还负责把自己持久化，封装了对数据库的访问(CRUD)。仅限于此，不允许封装其他的业务规则。
> 这东西似乎挺老....我也没接触过，大致等于DAO层的方法和数据库DTO的一个混合体。
[博客介绍](https://blog.51cto.com/zhaocz/307894)

### 第七章 异常
1. 使用异常而非状态码。作者认为不应该定义一系列的状态码，进行一堆if判断，才走入下一层。应当全部用try包起来，在方法中throw异常，最后由catch接收处理。
> 事实上，由于现在框架的应用已经很深了，类一层套一层，这种抛异常的方式会导致一条链路上都要Throw xxx，最终汇聚到异常处理中。这其实是很烦的一件事。如果只是一个简单的contorller倒是没问题，但是在具体的开发环境中，还需要结合实际考虑。[这里其实就是7.3所讲述的"已检异常"]
2. 在任何情况下都不要返回null值，或者向方法中传入null值。
> 对于这一条我是十分赞同且双手支持。判null着实把我判烦了，而且null防不胜防。在任何情况下都不要返回nll。至于传入null，这一条很难控制，上游给什么其实是很无语的一件事情。、

### 第八章 边界