
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [代码整洁之道](#代码整洁之道)
  - [第二章 有意义的命名](#第二章-有意义的命名)
  - [第三章 函数](#第三章-函数)

<!-- /code_chunk_output -->


## 代码整洁之道
***
### 第二章 有意义的命名
1. 类名应该使用名词或名词短语，方法应该使用动词
2. 不要用“双关”，同样的方法名，用在两个相似的地方。例如向DB插入一条数据使用add(),像集合插入一个元素也使用add()，本质上其实是不同的。
3. 命名不要又臭又长且相似。
> *这种类名我看到过很多，我非常想掐死命名的人。*

### 第三章 函数
1. 函数要尽可能地短小。
> *yysy,这个我无法理解。书中将三五行代码拆成一个命名精准的方法，这将导致整个文件中四处都是简短的方法，观感上很烦。甚至将if、else中的代码块再包一层，让代码块只占一行。作者提出一个想法：代码的缩进层级不多于一层或两层。*
2. 一个函数应当只做一件事
> *这个思想我认可。方法名实际上也只能代表一件事，通过方法名我应该能明确知道内部做了什么。如何做到这一点？作者给了一个想法：方法是否能再拆除一个方法。*
3. 函数中的操作需要在同一个抽象层级
> 很难理解这个抽象层级。大体上约细粒度，越精确的行为就是越低抽象级。

作者提出：所有的方法中的内容应该是同一个抽象层级的。方法及方法内的方法，应该符合*总-分-再分*的这种模式。
> 就我个人而言，我更喜欢将总-分-再分，写在一个方法中当成一个模块，而非再抽象层级上进行划分。我不确定那种更合适，不过作者的方法会更灵活，但是书写更繁琐，大量的冗余。我的方式随着业务的增加，模块越大，阅读起来可能会越痛苦。---**不过我发现实际上优秀的源码，都会采用作者的方式。**

4. 关于switch，作者反对无脑的往里面做分支。转而采用逆向思维，不是单纯的在switch中写代码，而是将switch分支中的条件使用抽象工厂埋藏起来。
> 这种方式虽然没有减少代码量，也没有看起来更好看，实际上还增加了复杂度。但是对日后的扩展有很大的好处，抽象工厂类可以直接增加具体的类型。*yysy，不是很懂...先看GOF会不会好理解一点*

5.  使用具有描述性的名称
> 作者表示，方法名可以长
6. 函数参数越少越好。作者认为最好的参数数量是0，如非必要无论如何不能多于3及以上。
``` txt
6.1 单参数的函数形式
传入单个参数一般是三种形式：
a. 对入参进行判断或校验
b. 对入参进行操作并输出
c. 是一种事件(event)，有入参无出参,使用该参数修改系统状态
```  
> 在这里作者提出了一个想法：所有的单参数都应该遵循以上三种类型。对于常见的“转换”逻辑，转换结果就应该体现为返回值，而不是很多人喜欢的，将一个DTO扔到方法里，一通转换最后修改了入参DTO中的值。**如果严格按照作者单参数用法来看，我对于进房接口的划分处理就是💩，我新建了一个context作为上下文，在整个代码逻辑中填充context的所有字段，并且没有出参**

``` txt
6.2 标识参数(布尔值参数)
```  
 作者认为，在入参中写布尔值是及其SB的做法。对于所有需要布尔值作为标识的函数，都应该拆成两个，针对不同情况去执行方法。

 > 作者对于布尔值入参的态度...我不予评价。不过我在日常工作中确实也极少使用布尔值入参。
 ``` txt
6.2 双参数函数
``` 
作者对双参数的函数态度尚可。肯定有存在的必要，但是大部分情况下还是鼓励能改成单参，就单参。
``` txt
6.3 三参数函数
``` 
> 作者没怎么评价三参数函数...但是举的例子我愣是没看懂，不像java啊....
``` txt
6.4 动词和关键字
函数名和参数最好可以形成动名词的联动，例如write(name)
``` 
> 这点我很认同，也很符合人性...一眼就能知道这个函数是干什么的。

另外，关于3.6本节，作者还提了：对于大量参数，应该使用参数对象进行封装；对于可变参数(...arg)，应该当成一个List参数来看待。

7. 无副作用，函数应该只做一件事，并且方法命中也应该明确的体现该方法制作了一件事。
>个人非常认同，但是coding的过程总是触犯上述错误。

作者*输出参数*有想法：例如我常常写的liveRoomInfo(xxx, xxx)此类方法。本意是对入参进行修改，并且修改入参的属性状态。作者认为liveRoomInfo.xxx()对于这类行为更合适。更"**面向对象**"。
8. 作者认为函数要么，做什么事，要么回答什么事，二者不可兼得。例如，设置属性的方法，和判断属性的方法应该是两个。不应该在一个方法中做，设置某个属性成功，则返回true，如果不存在这个属性返回fasle，这种行为。
> 我认为这个说法是正确的，但是在coding过程中很容易忽略。判断一件事，和做一件事，应该显然是两个方法。
9. 关于异常处理，作者提出以下想法
```txt
1. 不应该使用自定义的错误码来代替异常。这样可能会有一大堆if嵌套 
2. 抽离try/cactch中的代码，封装成单独方法，对外抛异常，由catch接收
3. 如果存在try内容，那么应该是这个函数的第一行开始，并且在catch/finally代码块中不做任何与错误无关的事情。
4. ErrorEnum.java，类似的状态码枚举类会被多个应用所引入。当枚举类修改时候，下游需要重新编译和部署。而使用异常代替错误码，新的异常可以从异常类派生出来，无需重新编译。
```
> 事实上，对于3.try/catch在工作中常常被用来做正常业务逻辑的万能兜底，而非是针对错误的处理（但好像兜底理解为针对错误的处理也没有问题）。对于4.不理解重新编译和部署是个什么意思...发线上不是肯定重新部署的吗？

### 第四章 注释
开宗明义，作者认为：**注释是一种代码上的失败**。
所以...多余的也不用打了。作者认为是shit。
### 第五章 格式
1. 第一小节没什么新鲜的，主要思想还是一个类的代码行数尽量小，中位数应该不高于100行。