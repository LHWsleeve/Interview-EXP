# 第二章：Java 内存区域与内存溢出异常

## 1.运行时数据区域

![运行时数据区域](asserts/运行时数据区域.png)
Java 虚拟机执行 java 的过程中会把他所管理的内存划分为若干个不同的数据区域。
这些区域有各自的用途，以及创建，销毁的时间。(随着虚拟机进程的启动而一直存在，有些区域依赖用户线程的启动和结束而建立和销毁)

<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png" width="600px"/>
</div>

### 1.1 程序计数器(programing counter register)

- 是一块较小的内存空间，可以当成**当前线程**所执行的==字节码的行号指示器==。
- 字节码解释器的功能：通过改变这个计数器的值来选取下一条需要执行的字节码指令，这是程序控制流的指示器(分支，循环，转跳，异常处理，线程回复等)
- 由于 java 虚拟机的多线程是由线程轮流切换，分配处理器执行时间实现的。**在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令**，因此为了线程切换后可以恢复到正确的执行位置，==每一个线程==都需要一个单独的程序计数器。
- 每一个线程的程序计数器部分的内存区域互不影响，独立存在-----**_线程私有内存_**。
  如果线程正在执行 java 方法，计数器记录的是正在执行的==虚拟机字节码指令地址==;若执行 Native 本地方法，计数器值应为空。

**所以为什么为空？**：<font color="red">C++解释：</font>当线程中调用 native 方法的时候，则重新启动一个新的线程，那么新的线程的计数器为空则不会影响当前线程的计数器，相互独立。。也就是说程序计数器是为我们的线程的**java 字节码文件**进行服务的，而不是其他语言，**本地的一些方法大多数都会直接映射到其原生平台，没有我们 jvm 什么事情**。

《Java 虚拟机规范》中未规定程序计数器此内存区域内的溢出异常。

### 1.2 Java 虚拟机栈

- 虚拟机栈是线程私有的
- 生命周期=线程
- 虚拟机栈描述 Java 方法执行的线程内存模型：每个方法被执行的时候，java 虚拟机会同步创建一个栈帧用域存储局部变量表，操作数栈，动态链接，方法出口等信息。---每个方法被调用，直到执行完毕的过程对应着**一个栈桢在虚拟机栈中入栈和出栈的过程**。
- 通常我们日常所说的虚拟机中的**栈**指的就是**Java 虚拟机栈**，更是特指虚拟机栈中的**局部变量表**部分。
- 进步变量表存放了编译期可知的各种 Java 虚拟机基本数据类型(short,int,...,references(**对象引用，她并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象句柄或其他与此对象相关的位置**))。
- 方法运行期间不会改变局部变量表的大小。即不会改变变量槽的数量，**虚拟机真正使用多大的内存空间来实现一个变量槽，是完全有虚拟机实现自行决定的**---(一个变量槽占 32bit，还是 64 比特)。

《规范》中，对此内存区域规定两种 u 异常：

1. 线程请求深度大于虚拟机所允许最大深度---StackOverflowError
2. 如果 java 虚拟机栈动态扩展，当栈扩展无法申请到最够的内存--OutOfMemoryError

### 1.3 本地方法栈

- 和 Java 虚拟机栈作用类似，区别是虚拟机栈位 java 方法提供服务，而此栈为本地方法执行服务。
  异常情况：
  与虚拟机栈相同

### 1.4 Java 堆

- Java 堆是虚拟机所管理的内存中最大的一部分。
- Java 堆是被==所有线程共享==的一块内存区域，**虚拟机启动时创建**。
- ==此内存区域唯一是存放对象实例==，几乎所有对象实例都在这里分配内存。
- Java 堆是垃圾收集器管理内存的区域，又被称为 GC 堆
- 从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个==线程私有的分配缓冲区(TLAB)==,以提升对象分配时的侠侣。**不过无论如何划分，都不会改变 Java 堆中存储内容的共性---只能是对象的实例**，Jav 堆细分的目的只是为了更好的进行内存回收，或内存分配。
- Java 堆可以处于物理上不连续的内存空间中，但逻辑上是连续的。但是对于大对象，例如数组对象，虚拟机常连续存放。

异常规定：

1. Java 堆无法在分配内存，无法扩展，抛出---OutOfMemoryError

### 1.5 方法区

- 各个线程共享的内存区域，它用来存储被虚拟机加载的类型信息，常量，静态变量。即时编译器编译后的代码缓存等数据
- JDK8 以前，很多人把方法区等同于永久代。本质上这二者并不等价，只是用永久代实现了方法区，这使得 HotSpot 的垃圾收集器分代设计扩展到方法区，方便设计。其他某些虚拟机时没用永久代概念的。这种设计方式，道指 Java 应用给更容易遇到内存溢出问题。JDK8 之后，终于把原先永久代中所有信息全部一如元空间。
  在此之后，使用元空间来实现方法区
  异常规定：

1. 方法区无法满足新的内存分配--OutOfMemoryError

### 1.6 运行时常量池

- 运行时常量池是方法区的一部分。这里存放常量池表，用与存放编译期生成的各种字面量与符号引用。再类加载后存放到方法去的运行时常量池中。
- 运行时常量池和 Class 文件常量池的重要区别是，**具备动态性**。Java 语言并不要求常量一定只有编译器参能产生，即，非预置入 Class 文件常量池的内瓤才能进入方法区运行时常量池。运行期间也可以放入该常量池。--String 的 intern()方法。。我也没用过，我也不懂。。
  异常规定：
  隶属于方法区，所以和方法区一样。

### 1.7 直接内存

- 注意，这不是虚拟机运行时数据区的一部分，也不是《规范》定义的内存区域，但是会被平凡使用并可能导致 OutOfMemoryError。
- JDK4 中加入了 NIO 类，引入了一种基于通道的缓冲区，可以使用 Native 函数库直接**分配堆外内存**，然后通过存储在==Java 堆==里面的 DirectByteBuffer
  规定异常：
  本机直接内存的分配，不会受到 Java 堆大小限制，但是既然是内存，一定会受到本基机总内存限制。当各个内存区域总和大于物理内存限制，会报错：OutOfMemoryError

## 2 HotSpot 虚拟机对象

这只讨论最简单的 new 创建对象

#### 2.1 对象创建

当 Java 虚拟机遇到一条字节码 new 指令时

1. 首先检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析和初始化。如果没有必须先执行类加载
2. 类加载检查通过后，虚拟机为新生对象分配内存，==对象所需内存大小在类加载完成之后，完全确定。==
3. 对于内存分配，分为两种 a. 指针碰撞，单纯的物理上连续的顺序划分。b.空闲列表，即物理上不连续的分配，虚拟机必须要维护一个列表，记录那些内存是可用的。
4. 选择那种分配方式，由 Java 堆是否规整决定。如果采用的垃圾收集器带有空间压缩整理的能力，用空闲列表，否则就是指针碰撞。

除了对象内存分配，还需要考虑**线程安全**问题：有可能出现再给 A 分配内存，指针还没来得及修改，对象 B 又同时使用用了原来的指针分配内存。

两种方法 ：

1. 对分配内存控键的动作进行同步处理---采用 CAS 配上失败重试的方法保证更新操作的原子性。**CAS 不懂，要看资料**
2. 吧内存分配这个动作按照线程划分在不同的空间中进行--即在 Java 堆中预先分配一小块内存，称之为 TLAB。哪个线程要分配，就在那个现成的本地缓冲区 TLAB 中分配。

内存分配完成后，虚拟机必须讲分配到的内存空间(不包括对象头)初始化。TLAB 其实可以把这部完成

设置对象：例如对象时哪一个类的实例，如何才能找到类的元数据信息，对象的哈希码，GC 分代年龄信息等等。这些需要放置到对象头中。

此时，在虚拟机中对象已经产生了，但是在程序员视角中，对象创建才刚刚开始---构造函数。即，Class 文件中的`<init>()`方法还没有执行，所有字段时默认值，对象所需的自愿和状态未加载。---随后才会逐一构造

### 2.2 对象的内存布局

HotSpot 虚拟机对象的对象头部分包括两类信息。

1. 用于存储对象自身的运行时数据。例如哈希码，GC 分代年龄，锁状态标志等等。这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32bit 和 64bit。但是实际上对象要存储的运行时数据很多，已经超出了 32，64 位 BitMap 的极限。由于对象头里的信息，与对象自身无关的数据，我们将 Mark Word 设计成**动态定义的数据结构**
   在==对象未被同步锁锁定==的情况下，32 位 hotspot 虚拟机中，25bit 用于存储对象哈希码，4bit 分代年龄，2bit 用于存储锁标志位，1bit 固定为 0。其他状态如下：

| 存储内容                              | 标志位 | 状态             |
| ------------------------------------- | ------ | ---------------- |
| 对象哈希码，对象分代年龄              | 01     | 未锁定           |
| 指向锁记录的指针                      | 00     | 轻量级锁定       |
| 指向重量级锁的指针                    | 10     | 膨胀(重量级锁定) |
| 空，不需要记录信息                    | 11     | GC 标记          |
| 偏向线程 ID，偏向时间戳，对象分代年龄 | 01     | 可偏向           |

2. 类型指针，即对象指向它的类型元数据的指针---**Java 虚拟机通过这个指针确定该对象是那个类的实例**。但是并不是所有的虚拟机实现都必须在对象数据上保留类型指针。
   ==此外，如果对象是一个 Java 数组==，那再对象头中还必须有一块用于记录数组的长度，数组长度不确定，虚拟机无法从对象的元数据中推断出数组大小。

# 第三章 垃圾收集器与内存分配策略

为什么需要垃圾收集？
当需要排查内存各种内存溢出、内存泄漏问题时；当垃圾收集成为系统高并发的瓶颈时，我们必须对原本“内部自动化的”的技术进行监控和调节。
程序计数器，虚拟机栈，本地方法栈，这些随着线程而生，线程而灭。栈中的栈桢随着方法的进入和推出进行出栈和入站工作，每一个栈桢中分配多少内存，在类结构确定下来时就已经确定，所以这几个区域的内存分配和回收都具备**确定性**，方法结束内存自然回收，所以一般不关注这部分的垃圾回收。
Java 堆和方法区则有着显著的**不确定性**，只有处于运行期间我们才能知道要创建什么对象，多少对象，这涉及到**内存分配和动态回收**

## 3.1 如何判断对象死亡？

### 3.1.1 引用计数法

在对象中添加一个引用计数器，有一个地方引用，计数器值+1；当引用失效，计数器值-1；任意时刻计数器值为 0 的对象就不再被使用。
**但是此方法无法解决对象之间循环引用的问题。**

### 3.1.2 可达性分析算法

通过可达性分析算法来判断对象是否存活。算法的基本思路时通过一系列被叫“GC Root”的根对象作为起始**节点集**，从这些根节点开始根据引用关系乡下搜索(搜索的路劲被称之为"引用链")，如果某个对象 GC root 无法引用，则证明此对象不能再被使用。
**GC root 有以下几种：**

1. 虚拟机栈（栈桢中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法中 JNI(native 方法)引用的对象
5. Java 虚拟机内部的引用
6. 被同步锁只有的对象
7. 反应 JVM 虚拟机内部情况的 JMXBean，JVMTI 中注册的回调、本地代码等

### 3.1.3 引用的分类

过去仅仅讲引用分为：引用和未引用，过于简单。
JDK1.2 之后堆引用的概念进行了扩充，将引用分为四种，强度依次减弱：

1. **强引用**：传统的引用定义，代码中普遍存在。无论任何情况，只要强引用关系还在，垃圾收集器永远不会回收。
2. **软引用：** 用来描述一些还有用但是非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围中做二次回收，如果还不够，抛出内存溢出。
3. **弱引用：** 比软引用强度更低，仅能存活到下一次垃圾收集发生为止。
4. **虚引用：** 又称为幽灵引用，甚至无法通过它来获取一个对象实例，唯一目的只是为了能在这个对象被收集器回收的时候收到一个系统通知。

### 3.1.4 对象的生死

即使在可达性分析算法中判定为不可达的对象，也不是一定要被回收。宣告一个对象死亡至少要经过两次标记：

1. 可达性分析后发现没有与 GCroot 相连的引用链，第一次标记，随后进行筛选。筛选的条件是该对象是否有必要执行 finalize()方法。如果该对象没有覆盖此方法，或已经执行过此方法(只能执行一次)，那么虚拟机将认为没有必要执行该方法。
   若判断该对象有必要执行 finalize()方法，该对象会被放与 F-Queue 中，并新建一个线程去执行(此执行指标是会触发，但不一定等待执行结束，可以防止万一该线程出现死循环导致回收系统崩溃)。
2. 第二次标记则在 F-Queue 中，堆队列中的对象进行小规模标记，如果某对象在 finalize()中成功拯救自己--重新建立某种引用，则不会被回收。

注意：任何一个对象的 finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，不会再被执行。

**_！最好不要使用 finalize()方法_**

### 3.1.5 方法区回收

方法区(HptSopt 中的永久代或者元空间)的回收是没有性价比的，因为方法区回收的条件极其苛刻，收集性价比往往不高。
方法区回收的内容：废弃常量池中的内容和不再使用的类型。
前者和回收 java 堆类似
后者比较麻烦，需要同时满足三个条件：1. 该类所有实例都被回收。2. 该类的类加载器已经被回收，除非精心设计过，否则很难。3. 该类对应的 `java.lang.Class`方法没有在任何地方被引用---也就是无法被反射拿到。

## 3.2 垃圾收集算法

本文只讨论追踪式垃圾收集。

#### 3.2.1 分代收集理论

目前大多数垃圾收集器都遵循分代收集理论(应该只有 ZGC 不是？)
**该理论建立在两个假说之上:**

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说:熬过越多次垃圾回收的对象，越难以消亡。

这两个分代假说奠定了垃圾收集器的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象以具年龄分配到不同的区域中存储。
**对于朝生夕灭的对象，做垃圾回收时应当关注如何保留少量存货，而不是标记大量将要被回收的对象。对于强分代，应当把他们集中在一起，虚拟机将会以较低的频率收集这个区域。**

Java 堆划分为不同区之后，垃圾收集器被允许每次之回收一个部分区域--Minor GC，Major GC Full GC。通常会被划分为新生代和老年代，在新生代中每次收集对象都有大量的对象死去，每次收集后存活的少量对象**会被逐步**的放入老年代中存放。
但前述方式存在**跨代引用问题**：新生代中对象可能跨代引用老年代对象，为了找出跨代的问题，不得不需要在 GC root 外全局扫描所有老年代对象，但是这会造成巨大的性能消耗。

**存在第三条理论：**

3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。
   即，存在互相引用关系的两个对象，应该趋于同生同灭。

依据第三条假说，不需要再为极少数的跨代引用扫描全区，也不需要浪费空间记录每一个对象是否存在以及存在哪些跨代引用。只需要咋**新生代**生建立一个全局数据结构(**记忆集**)，该结构将老年代划分为若干个区，表示出老年代的哪一块内存存在跨代引用。运行时只有包含了跨代引用指定区域的老年代对象才会被加入 GC Root 扫描。

#### 3.2.1 标记-清除算法

最早最基础的算法。算法分为标记和清楚两个阶段
首先标记处所有需要回收的对象，在标记完成之后，同意回收掉所有被标记的对象；也可以反过来，标记存活对象，统一回收未标记的。
标记过程就是可达性算法啦。
**缺点：**

1. 执行效率不稳定，Java 堆汇中包含大量的对象，必须进行大量的标记和清除动作，导致执行效率随着对象数量增长而降低。
2. 内存空间的碎片化问题。标记清除后会产生大量不连续的内存碎片，可能导致日后分配大对象无法找到连续的而不得不触发垃圾收集动作。

#### 3.2.2 标记-复制算法

这是一种半区复制的垃圾收集算法，他将可用的内存按容量划分为大小相等的两块，每次只适用其中一块。当一半的内存使用完了，则复制存活对象到另一半，清楚现有空间。
**缺点：**
浪费了一半内存空间，过于奢侈。

过后又出现一种更优化的半区复制分代策略：具体做法是**把新生代分为一块较大的 Eden 空间，和两块较小的 Survivor 空间，每次分配只是用 Eden 和其中一块 survivor。发生垃圾收集时，将任然存活的对象一次性复制到另一块 survivor 上，然后清理本身。**
HptSpot 虚拟机默认 Eden 和 survivor 的比例是 8：1，也就可用空间为新生代的 90%。当然不能保证每次存活对象都再 10%以内，所以当超出时，借助其他内存区域进行分配担保。

**为什么需要两个 survivor：**
==设置两个 Survivor 区最大的好处就是解决了碎片化。==

**假设现在只有一个 survivor 区：**
刚刚新建的对象在 Eden 中，一旦 Eden 满了，触发一次 Minor GC，Eden 中的存活对象就会被移动到 Survivor 区。
这样继续循环下去，下一次 Eden 满了的时候，问题来了，此时进行 Minor GC，Eden 和 Survivor 各有一些存活对象，如果此时把 Eden 区的存活对象硬放到 Survivor 区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。

白色框分别代表 Eden 区（大）和 Survivor 区（小）
![asserts/one_survivor.png](asserts/one_survivor.png)
碎片化带来的风险是极大的，严重影响 JAVA 程序的性能。堆空间被散布的对象占据不连续的内存，最直接的结果就是，堆中没有足够大的连续内存空间。

顺理成章的，应该==建立两块 Survivor 区==，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0 和 Eden 被清空，然后下一轮 S0 与 S1 交换角色，如此循环往复。如果对象的复制次数达到 16 次，该对象就会被送到老年代中。
![](asserts/two_survivor.png)

上述机制最大的好处就是，==整个过程中，永远有一个 survivor space 是空的，另一个非空的 survivor space 无碎片。==

#### 3.2.3 标记-整理算法

标记整理算法一般针对老年代算法。因为老年代存活率较高，不适合复制，同时我们也不想浪费内存空间。

如果**移动存活对象**，尤其是在老年代这种每次回收都有大量对象存活的区域，移动对象并更新引用是极大的负担。==另外这种移动对象的操作必须**全程暂停用户程序**才能进行==。

如果**不移动对象**，采用标记清除算法，弥散再空间中的碎片文件会影响**程序吞吐量**。
即，关注吞吐量的收集器采用标记整理算法，关注低延迟的收集器采用标记清除算法。

或是采用和稀泥方式，平时多数时间采用标记清楚算法，当内存空间的碎片化程度影响对象分配的时候，采用标记整理手机一次。实际上 CMS 面临空间碎片过多时就这样采用标记整理算法。

## 3.3 HotSPot 算法细节实现

### 3.3.1 根节点枚举

迄今为止，**所有收集器在根节点枚举这一步骤时都必须暂停用户线程**。现在可达性分析算法耗时最长的查找引用链的过程，已经可以做到与用户线程一起并发，但是根节点枚举这一步骤始终还是必须在一个能**保障一致性的快照中**得以进行。(即，枚举期间必须被冻结在某个时间节点)。
目前主流垃圾收集器都是用准确式垃圾手机(虚拟机可以知道内存中所有位置对应的类型)，虚拟机有办法直接得到内存中某位置的引用，实际上 HotSpot 使用 OopMao 的数据结构来存储。

#### 3.3.2 安全点 safepoint

可能导致引用变化的关系非常多，如果所有都用 OopMap 存储，需要大量额外空间。所以只需要在特定位置进行记录信息即可---**安全点**。
安全点决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，儿是**强制要求必须大导安全点后才能够暂停**。
安全点的设置要考虑两个问题：

1. 安全点的设置不能太少导致收集器等待时间够长，也不能太多以至于增大内存运行负荷。
2. 如何在垃圾收集发生时让所有线程都跑到最近的安全点。我们采用两种方案：
   1. **抢先式中断**：不需要线程的执行代码主动配合，垃圾收集发生时，系统闲全部中断所有用户线程，如果中断不在安全上，重启该条线程，跑到安全点停止。
      目前几乎没有采用这种方式。
   2. **主动式中断**：设置一个标志位，各个线程执行过程时会主动轮询这个标志，一旦发生中断，标志位为真时，个线程在最近的安全点主动中断挂起。（轮询操作很频繁，所以必须高效，在 HotSpot 中使用内存保护陷阱的方式，只需要一条汇编指令即可完成）

#### 3.3.3 安全区域

安全点记之保证了程序执行时，在不太长的时间内就会可以进入垃圾收集过程的安全点。但是**程序不执行的时候是个麻烦(线程被挂起，入 sleep()，wait())**,此时线程无法响应虚拟机的中断请求，无法自己到安全点中断挂起自己。此时我们需要安全区域

**安全区域：**确保能够在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。
当哟个胡执行到安全区域的代码时：

1. 首先会表示自己一斤进入安全区域，此时如果进行垃圾收集不必管安全区的代码
2. 当线程离开安全区域，检查虚拟机是否完成根节点枚举
3. 如果完成，线程继续，如果未完成，一直等待。

#### 3.3.4 记忆集与卡表

记忆集：解决对象跨代引用带来的问题，该数据结构可以避免把整个老年代放入 GC Root 扫描。
**这是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。**收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，并不需要详细了解跨代指针的全部细节。
**精度选择**:

1. 字长精度：每个记录精确到一个机器字长，该字长长度内包含跨代指针
2. 对象精度：精确到对象，对象内有跨代指针
3. 卡精度：精确到某一个区域，区域内存在跨代指针。

第三种使用最多，通过**卡表(card table)**的方式去实现记忆集，卡表示记忆集的具体实现，定义记忆集的记录精度，与堆内存的映射关系。
通常字节数组 Card_Table 中的每一个元素都对应着其表示的内存区域中一块特定大小的内存块，这个内存块被称之为**卡页**(通常是 2 的 N 次幂)。
一个卡也得内存中通常包含不止一个对象，只要卡业内有一个或多个对象的字段存在跨代指针，那么将对应卡表的数组元素的值标识为 1，此时这个元素**变脏**。当发生垃圾收集时，只需要把标识为 1 的区域对象放入 GC Root 中扫描即可。

#### 3.3.5 写屏障

卡表如何维护，如何标识？
当有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏的时间点原则上应该发生在引用类型字段赋值的那一刻。我们需要一个机器码层面的手段，把维护卡表的动作放在每一个赋值操作之中。
HotSpot 中通过**写屏障技术**来维护卡表状态。**写屏障可以看作在虚拟机层面对”引用类型字段赋值“这个动作的 AOP 切面，在引用对象赋值的时候会产生一个环绕通知，赋值前后都在写屏障的覆盖范畴**。赋值前时写前屏障，赋值后是写后屏障。

除了写屏障之外，在高并发场景下 还面临**伪共享**的问题。当多线程修改相互独立的变量时，如果这些变量恰好在同一个 cache Line 时，就会彼此印象而导致性能降低。
由于一个卡表占一个字节，可能多个卡表占据一个 Cache Line ，就会导致更新卡表时恰好写入同一个缓存行而影响性能。

为了避免伪共享问题，简单的解决方案时不采用无条件的写屏障，儿是先检查卡表标记，只有该卡表匀速未被标记国时才将其标记为变脏。

#### 3.3.6 并发的可达性分析

可达性分析必须要在一个保障一致性的快照中进行，此时用户线程必须冻结。在初始的根节点枚举中 GC Root 相对是极少数，并且在 OopMap 的加持下，停顿时间相对固定。但是在随后的根节点扫描中，与 Java 堆容量成正比。
首先我们要解决并发扫描时对象消失的问题：

1. **增量更新：**当出现新的指向关系时，记录下这个新插入的引用，并发扫描结束之后，从该记录重更新扫描。CMS

2. **原始快照：**当删除只想关系时，记录删除引用，并发扫描结束之后，从删除点重新扫描。G1,Shenandoah
   以上无论是删除还是新增的记录操作都是通过**写屏障**实现的

### 3.4 经典垃圾收集器

![asserts/垃圾收集器.webp](asserts/垃圾收集器.webp)
上面为新生代收集器，下面是老年代收集器。如果两个收集器之间存在连线，就说明它们可以搭配使用。

新生代的收集器使用复制算法，
老年代使用并发标记清除（CMS）或标记-整理算法。
序号|收集器|收集范围|算法|执行类
-|-|-|-|-|-
1| Serial| 新生代| 复制| 单线程|
2 |ParNew| 新生代| 复制 |多线程并行|
3 |Parallel |新生代| 复制| 多线程并行|
4| Serial Old| 老年代| 标记整理| 单线程|
5 |CMS| 老年代| 标记清除| 多线程并发|
6| Parallel Old| 老年代| 标记整理| 多线程|
7 |G1 |全部 |复制算法，标记-整理| 多线程|

#### 3.4.1 Serial(串行 GC)收集器

Serial 收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必 须暂停其他所有的工作线程(用户线程)。是 Jvm client 模式下默认的新生代收集器。对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单 线程收集效率。
迄今为止，serial 依然是客户端模式下的默认新生代收集器，简单高效，对于内存资源受限的环境，他是所有收集器里内存消耗最小的。由于没有线程交互的开销，性能效率高。
![asserts/Serial(串行GC)收集器.webp](<asserts/Serial(串行GC)收集器.webp>)

#### 3.4.2 ParNew(并行 GC)收集器

ParNew 收集器其实就是 serial 收集器的多线程并行版本，除了使用多条线程进行垃圾收集之外，其余行为与 Serial 收集器一样。该收集器是服务端模式下的默认模式，另外这是**CMS 作为老年代收集器的默认搭配新生代收集器。**

![asserts/ParNew(并行GC)收集器.webp](<asserts/ParNew(并行GC)收集器.webp>)

#### 3.4.3 Parallel Scavenge(并行回收 GC)收集器

Parallel Scavenge 收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge 收集器的目标则是达到一个 **==可控制的吞吐量==**。

==吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)==，虚拟机总共运行了 100 分钟。其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。
**停顿越短时间就越是和需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验。
高吞吐量则可以最搞笑的利用处理器资源，因快完成程序运算任务，主要是和在后台运算而不需要太多交互的分析任务。**

**使用如下 2 个参数进行控制吞吐量:**

1.** -XX:MaxGCPauseMillis：最大垃圾收集停顿时间**
MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过这个时间并不是万能的，不会设置的小一点系统收集速度会变得更快，**垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价的**。系统把新生代调小，收集停顿时间缩短，但是会导致垃圾回收的频率增大，原先十秒收集一次，停顿 100ms，现在 50 秒手机一次，停顿 70ms，停顿时间减少的同时，吞吐量同时下降。

2. **-XX:GCTimeRatio：垃圾收集时间占总时间比率**
   GCTimeRatio 参数的值应当是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是==吞吐量的倒数==。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1 /（1+19）），==默认值为 99==，就是允许最大 1%（即 1 /（1+99））的垃圾收集时间。

由于 parallel scavenge 与吞吐量密切相关，所以又被称之为**吞吐量优先收集器**。还有第三个参数：
**-XX:+UserAdptiveSizePolicy**：该参数被激活后，不需要人工置顶新生代大小，eden，survivor 区比例等，**虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。**

#### 3.4.4 Serial Old(串行 GC)收集器

Serial Old 是 Serial 收集器的老年代版本，它同样使用一个单线程执行收集，使用 **“标记-整理”算法**。主要使用在 Client 模式下的虚拟机。如果在 Server 模式下，它主要还有两大用途：一个是在 JDK 1.5 及之前的版本中与 Parallel Scavenge 收集器搭配使用，另外一个就是作为 CMS 收集器的后备预案。如果 CMS 收集器出现 Concurrent Mode Failure，则 Serial Old 收集器将作为后备收集器。

#### 3.4.5 Parallel Old(并行 GC)收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程并发和 **“标记-整理**”算法。
在注重吞吐量或处理器资源稀缺的场合使用

![asserts/Paralle_Old(并行GC)收集器.webp](<asserts/Paralle_Old(并行GC)收集器.webp>)

#### 3.4.6 CMS(并发 GC)收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS 收集器是基于“标记-清除”算法实现的，整个收集过程大致分为 4 个步骤：

1. 初始标记(CMS initial mark)
2. 并发标记(CMS concurrenr mark)
3. 重新标记(CMS remark)
4. 并发清除(CMS concurrent sweep)

其中**初始标记、重新标记这两个步骤任然需要停顿其他用户线程**。初始标记仅仅只是标记出 GC ROOTS 能直接关联到的对象，速度很快，并发标记阶段是进行 GC ROOTS 根搜索算法阶段，会判定对象是否存活。
重新标记阶段则是为了**修正并发标记期间**，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。

由于整个过程中耗时最长的==并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作==，所以整体来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

**CMS 收集器的优点：并发收集、低停顿**
CMS 还远远达不到完美，器主要有**三个显著缺点：**

1. CMS 收集器对 CPU 资源非常敏感。(事实上面向并发设计的程序都对处理器资源敏感)
   在并发阶段，==虽然不会导致用户线程停顿，但是会占用 CPU 资源而导致引用程序变慢，总吞吐量下降==。CMS 默认启动的回收线程数是：(CPU 数量+3)/4。（建议 CPU 个数最少 4 个）。

2. 无法处理浮动垃圾
   **浮动垃圾**：程序运行时会不断伴随新的垃圾对象产生，这一部分垃圾对象出现在标记过程结束以后，CMS 无法再当此收集中处理他们，必须在下一次收集时清理掉。
   在做垃圾回收的过程中用户线程也再执行（并行执行），所以需要预留一部分空间给用户线程使用。**必须要留一部分空间供并发收集时的程序运作使用。**
   可以使用-XX:CMSInitiatingOccupancyFraction（jdk1.6 默认为 92%）参数来设置，预留多少空间开始做 GC。如果在垃圾回收的过程中，剩余空间不足仍然满足不了用户线程生成对象所需要的空间，就会出现 ==“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集==，这样停顿时间就很长了。

3. CMS 是基于“**标记-清除”** 算法实现的收集器，使用“标记-清除”算法收集后，**会产生大量碎片**。
   空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，**内存空间找不到连续的空间来分配不得不提前触发一次 Full GC**。为了解决这个问题，CMS 收集器提供了一个-XX:UseCMSCompactAtFullCollection 开关参数，用于在 Full GC 之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction 参数设置执行多少次不压缩的 Full GC 之后，跟着来一次碎片整理过程。

#### 3.4.7G1（Garbage First）里程碑式成果

G1（Garbage First）垃圾回收器开创了**面向局部收集的设计思路和基于 Region 的内存布局形式。** 主要面向服务端。
G1 是用在 heap memory 很大的情况下，把 heap 划分为很多很多的 region 块，然后并行的对其进行垃圾回收。
G1 垃圾回收器在清除实例所占用的内存空间后，还会做内存压缩。
G1 垃圾回收器回收 region 的时候基本不会 STW，而是基于 most garbage 优先回收 的策略来对 region 进行垃圾回收的。

**停顿事件模型**：能够支持在一个长度为 M 毫秒的时间片段内，小号在垃圾收集上的时间大概率不超过 N 毫秒这样的目标。
G1 可以**面向内存任何部分**来组成回收集进行回收，衡量标准不再是属於那个分代，儿是那块内存中存放的垃圾数量最多，回收收益最大。

G1 开创基于 Region 的堆内存布局，式实现这个目标的关键，虽然 G1 也准寻分代收集理论设计，但是：**G1 不在坚持固定大小以及固定数量的分代收集区域划分**，而是把连续的 Java 堆划分为多个大小相等的独立 Region，每个 Region 根据需要扮演分代和区，收集器能够对扮演不同角色的区域采用不同的策略。
**Region 中还有一类特殊的 Humongous 区域，专门存储大对象。**G1 认为只要超过 Region 容量一半就是大对象，通常 Region 在 1MB-32MB，对于超过一个 Region 的大对象，将会被存入连续的 Region 中。(通常把大对象当作老年代)
G1 保留老年代和新生代的概念，**但是二者不是固定的了**，他们将是一系列离散区域的动态集合，每次回收将 Region 作为最小单元，每次收集到 Region 空间的整数倍。
G1 收集器跟踪各个 Region 里面垃圾堆积的价值，维护一个优先列表，**每次根据用户设定的收集停顿时间，优先处理价值受益最大的区域。**

![asserts/Region分区.webp](asserts/Region分区.webp)
一个 region 有可能属于 Eden，Survivor 或者 Tenured 内存区域。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，T 表示属于 Tenured 内存区域。图中空白的表示未使用的内存空间。G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。这种内存区域主要用于存储大对象-即大小超过一个 region 大小的 50%的对象。

**G1 收集需要解决的问题**：

1. Region 里面的跨 Region 引用如何解决。
   每个 Region 都会维护自己的记忆集，记忆集会记录下别的 Region 只想自己的指针并标记的卡页范围。但是由于 Region 数量太多所以维护的记忆集很多，G1 收集器会占用更多的内存负担。
2. 并发标记阶段如何保证收集线程与用户线程互不干扰？
   G1 采用原始快照(SATB)算法来实现。
   此外垃圾收集器对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行一定会创建新对象。G1 为每个 Region 设计了两个名为**TAMS 的指针，把 Region 一部分空间划分出来并用域并发回收过程中的新对象分配，并发回收时新对象一定被分配到这两个指针范围内。** 垃圾收集器默认存活，不会被纳入回收。
   如果**内存回收速度，赶不上内存分配速度**，G1 收集器被迫冻结用户线程，进行长时间停顿执行 Full GC
3. 如何建立可靠的停顿预测模型
   **G1 收集器的停顿预测模型是以衰减均值理论为基础实现的**。在垃圾收集过程中，G1 收集器会记录每个 Region 回收的好事，每个记忆集里脏卡数量等成本，并分析的雏军之等。Region 统计更新越快，越能决定其回收的价值，然后通过这些信息预测现在开始回收有哪些 Region 组成回收集才可以在不超过期望停顿时间的约束下去的最高收益。

G1 收集器运作过程划分为四个步骤：

1. **初始标记：** G1 收集器仅仅标记下所有的 GC Root 能直接挂链的对象，并修改 TAMS 的值，让下一阶段用户线程并发运行时，能在正确的区域分配对象。该过程是和 Minor GC 的暂停过程一起的，所以耗时很短。
2. **并发标记：** 从 GCRoot 开始进行可达性分析，递归扫描整个对立的对象。耗时较长，但可以和用户并发执行，扫描安安城后，重新处理 STAB 记录下的并发时有引用变动的对象。
3. **最终标记：** 对用户线程做短暂暂停，用域处理并发阶段结束后遗留下来的最后少量的 STAB。
4. **筛选回收：**各个 Region 的回收价值和成本排序，根据用户的期望停顿时间来指定回收计划，自由选择组成回收集，**把据欸的那个回收的 Region 存活对象复制到空的 Region 中，在清理掉整个旧的 Region**，==涉及对象移动，必须暂停用户线程==。
   G1 回收器除了并发标记外，其余阶段也是用户线程停顿的。并非存粹的追求低延迟，停顿用户线程能够最大幅度的提高垃圾收集效率，保证吞吐量，
   **存粹的追求低延迟，去找 ZGC!**

![asserts/G1.jpg](asserts/G1.jpg)

**G1 中虽然可以指定用户期望停顿时间，但是这不是万能的**。如果设置过低可能出现，由于停顿目标时间过短，导致每次回收集只占据堆内存极小一部分，收集速度跟不上内存分配速度，最终栈满堆栈，出发 Full GC。

**G1 和 CMS 比较**
==优点:==
可控制最大提顿时间，分 Region 内存布局，按收益动态回收；
G1 整体上基于标记-整理算法实现的收集器，但从局部(两个 Region)上时基于标记-复制算法实现，无论如何意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完之后可以提供完整规格的可用内存。
==缺点==：
G1 比 CMS 有更大的内存占用和执行时额外的负载。
内存占用：无论新生代还是老年代，G1 需要维护每个 Region 的记忆集，而 CMS 只有一个，并且仅仅是老年代到新生代的引用。
执行负载上：CMS 使用写后屏障来维护卡表；而 G1 除了这个之外，**还需要实现 STAB，还需要写前屏障来跟踪并发时的指针变化**，在用户程序运行过程中会产生由跟踪引用带来的额外负担。
由于 G1 的写屏障比 CMS 消耗更多资源，所以 CMS 的写屏障实现时直接同步操作，而**G1 不得不实现为一个消息队列**，吧写屏障和写后屏障都放入队列中，然后异步执行。

目前在小内存应用上 CMS 表现大概率会好于 G1，大内存会反过来。这个平衡点大约在
6-8GB。

### 3.6 低延迟垃圾收集器（最后在加上吧）
