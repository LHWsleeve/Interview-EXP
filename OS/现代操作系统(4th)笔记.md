# 进程与线程
## 2.1 进程
在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程, 简称进程 ( process) 。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变批的当前值。从概念上说，每个进程拥有它自己的虚拟CPU。当然，实际上真正的CPU在各进程之间来回切换。

## 2.2 进程的创建
在UNIX系统中，只有一个系统调用可以用来创建新进程： fork 。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，这**两个进程（父进程和子进程）拥有相同的内存映像、同样的环境字符串和同样的打开文件**。

在UNIX和Windows 中，进程创建之后，父进程和子进程有**各自不同的地址空间**。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中，子进程的初始地址空间是父进程的一个副本，但是这里涉及两个不同的地址空间，==不可写的内存区是共享的==。某些UNIX 的实现使程序正文在两者间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但这种情况下内存通过写时复制 (copy-on-write} 共享，这意味着一且两者之一想要修改部分内存，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。再次强调，==可写的内存是不可以共享的==．但是，对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，诸如打开的文件等 。在Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的．

## 2.3 进程的终止
通常由下列条件引起：
1) 正常退出 （ 自愿的 ）。
2) 出错退出（自愿的 ） ．
3) 严重错误（非自愿 ） 。
4) 被其他进程杀死（非自愿）．
## 2.4 进程状态
1 ) 运行态（该时刻进程实际占用 CPU) 。
2) 就绪态（可运行，但因为其他进程正在运行而暂时停止）。
3) 阻塞态（除非某种外部事件发生，否则进程不能运行）．

## 2.5 内核中实现线程
将线程表放入内核。当某个线程希望创建一个新线程活撤销一个已有线程时，对他进行系统调用。通过堆县城表的更新完成线程创建或撤销操作。
内核的县城表保存了每个线程的寄存器、状态和其他信息，这些信息和在用户空间中(原本多线程存放在用户空间进程表的运行时系统中)是一样的。另外内核还维护了传统的进程表。
相比于用户空间的线程，在内核空间中，线程的切换代价是很大的，所以某些系统采用回收重利用的方式使用线程。==但是和用户空间不同，内核空间的线程阻塞的时候，根据内核选择可以运行同一个进程中的另一个线程，而前者只能运行一个直到内核剥夺当前cpu时间。==
内核线程不需要任何新的、非阻塞系统调用。==另外，如果某个进程中的线程引起了页面故障，内核可以很方便地检查该进程是否有任何其他可运行的线程，如果有，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。==**显然非阻塞了**，这样做的主要缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止等）比较多，就会带来很大的开销。

## 2.6 混合实现
将用户及线程和内核级线程的优点混合起来。
 使用内核级线程，然后讲用户级线程与某些或者全部内核线程多路复用。**多个用户线程对应一个内核线程**。
这种方式：内核只识别内核级线程，并对其进行调度，一个内核线程会被多个用户线程多路复用。

## 2.7 调度程序激活机制
虽然内核级线程在某些方面由于用户级线程，但无可争议的是内核级线程的速度慢。
调度程序激活工作的目标是模拟内核线程的功能，但是为线程报提供通常在用户空间中才能实现的更好性能。==如果用户线程从事某种系统调用时是安全的，那就不应该进行专门的非阻塞调用或者进行提前桧查。==

## 3 进程间的通信
### 3.1 竞争条件
在一些操作系统中，协作的进程可能共享一些彼此都能读写的公用存储区。这个公用存储区可能在内存中（可能是在内核数据结构中），也可能是一个共享文件。调试包含有竞争条件的程序是一件很头痛的事。大多数的剃试运行结果都很好，但在极少数情况下会发生一些无法解释的奇怪现象。不幸的是，多核增长带来的井行使得竞争条件越来越普遍。
### 3.2 临界区
实际上凡涉及共享内存、共享文件以及共享任何资源的情况都会引发与前面类似的错误，要避免这种错误，关键是要找出某种途径来阻止多个进程同时读写共享的数据。换言之，我们要的是**互斥**。 
我们把对共享内存进行访问的程序片段称作**临界区**，如果我们用各种操作使得两个进程不可能同时处于临界区域内，就能避免竞争。
### 3.3 忙等待的互斥
1. 屏蔽中断：每个进程刚进入临界区后，立即屏蔽所有中断，离开时之前再打开终端。**把终端的权力交给用户进程是不明智的。如果一个进程屏蔽后不在打开，那么系统可能会中止。如果是多核，可能只对一个核有效。**
2. 锁变量：当一个进程想进入临界区，首先测试这把锁。如果锁是0，则该进程讲其设置为1并进入临界区。如果这把锁的值是1，则该进程将等待直到值变成0.==类似CAS，但是同样有ABA问题。==
3. 严格轮换法
   循环等待：即自旋锁。空转浪费CPU时间。
4. Peterson解法：
5. TSL指令(测试并加锁)：需要硬件支持。`TSL RX LOCK`
它将一个内存字lock读到寄存器 RX中，然后在该内存地址上存一
个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。
### 3.4 睡眠与唤醒
Peterson解法和TSL或XCHG解法都是正确的，但它们都有忙等待的缺点。这些解法在本质上是这样的：**当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。**
现在来考察几条进程间通信原语，它们在无法进入临界区时将阻塞，而不是忙等待。最简单的是sleep和wakeup 。 sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外 一个进程将其唤醒。 wakeup调用有一个参数，即要被唤醒的进程 。另一种方法是让sleep和wakeup各有一个参数，即有一个用于匹配sleep和wakeup的内存地址。
### 3.5 信号量
使用一个整型变让来累计唤醒次数，称作信号量。 一个信号朵的取值可以为0(表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作)。
 down和 up (分别为一般化后的sleep和wakeup)(==原子操作==)
 **down操作：** 则是检查其值是否大干0 。若该值大于0, 则将其值减1(即用掉一个保存的唤醒信号)继续执行，若该值为0, 则进程将睡眠，而且此时down操作井未结束。
**up操作：** 信号量的值增 1 。如果一个或多个进程在该信号量上睡眠，无法完成一个先前的 down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作。

### 3.6 互斥量(Mutex)
**如果不需要信号量的计数能力** ，有时可以使用信号量的一个简化版本，称为互斥量 (mutex) 。互斥量仅仅适用于管理共享资源或一小段代码。
互斥量只需要表示两个状态：加锁和解锁。


**问题：** ==**在用户级线程包中，多个线程访问同一个互斥量是没有问题的，因为所有的线程都在一个公共地址空间中操作。**==
有两种方案。 
第一种，有些共享数据结构，如信号量，可以存放在内核中，并且只能通过系统调用来访问。这种处理方式化解了上述问题。
第二种，多数现代操作系统 （ 包括UNIX和Windows) 提供一种方法，让进程与其他进程共享其部分地址空间。在这种方法中，缓冲区和其他数据结构可以共享。在最坏的情形下，如果没有可共享的途径，则可以使用共享文件。
### 3.7 管程
管程在任意时刻只能有一个活跃进程，这一特性使得管程能有效完成互斥。典型的处理方法是，当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果有，调用进程将被挂起， 直到另 一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进入。
**管程的互斥由编译器负责，通常做法就是一个互斥量或者二元信号量。(Mutex?)**
单单管程还不够，**引入条件变量**，wait和singal。一个管程过程发现它无法继续运行时（例如，生产者发现缓冲区满），它会在某个条件变量上（如full) 执行wait操作。该操作导致调用进程自身阻塞，井且还将另一个以前等在管程之外的进程调入管程。

### 3.8 消息传递
这种进程间通信的方法使用两条原语send 和 receive , 它们像信号朵而不像管程，是系统调用而不是语言成分 。 
## 3.9 屏障
最后一个同步机制是准备**用于进程组**而不是用于双进程的生产者－消费者类情形的。在有些应用中划分了若干阶段，除非所有的进程都就绪准备若手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当 一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏陓为止。
### 避免锁：读-复制-更新。
## 4 调度
1. 某些进程花费了绝大多数时间在计算上--==计算密集型==
2. 某些进程在等待I/O上花费了绝大多数时间--==I/O密集型==

**何时调度？**
1. 在创建一个新进程之后，需要决定是运行父进程还是运行子进程。由于这两种进程都处于就绪状态，所以这是一种正常的调度决策，可以任意决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。
2. 在一个进程退出时必须做出调度决策。 一个进程不再运行（因为它不再存在），所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程 ， 通常会运行一个系统提供的空闲进程。
3. 当一个进程阻塞在1/0和信号址上或由千其他原因阻塞时，必须选择另一个进程运行。
4. 在一个1/0中断发生时，必须做出调度决策。
==**非抢占式调度算法：**==挑选一个进程，然后让该进程运行直至被阻塞（阻塞在1/0上或等待另一个进程），或者直到该进程自动释放CPU。
==**抢占式调度算法：**==挑选一个进程，井且让该进程运行某个固定时段的最大值。到了时长就挂起。没有进程可以永远运行
### 4.1 批处理系统中的调度
批处理一般没人在一直等待，要求最大吞吐量，所以可以容忍长时间处理。一般采用非抢占式调度算法。
1. 先来先服务
2. 最短作业优先
3. 最短剩余时间有限
### 4.2 交互式系统中的调度
交互式系统一般在个人计算机里面，要求快速响应请求。 
1. 轮转调度算法。时间片，需要进程切换，浪费时间太多
2. 优先级调度算法。每个进程被赋予优先级，进程搞得先运行
3. 多级队列。设立优先级类。属于最高优先级类的进程运行一个时间片，属干次高优先级类的进程运行2个时间片，再次一级运行3个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。
4. 最短进程优先
5. 保证调度
6. 彩票调度
7. 公平分享调度
### 4.3 实时系统中的调度
避免数据丢失，满足多媒体系统中的数据传输；
**硬实时，软实时等**

### 4.4 策略和机制
有时也有这样的情况： **一个进程有许多子进程井在其控制下运行。**
例如，一个数据库管理系统可能有许多子进程，每一个子进程可能处理不同的请求 ， 或每一个子进程实现不同的功能（如请求分析，磁盘访问等）。**主进程完全可能掌握哪一个子进程最重要（或最紧迫）而哪一个最不重要**。但是，以上讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。
**解决问题的方法是将调度机制与调度策略分离。** 也就是将调度箕法以某种形式参数化，而参数可以由用户进程填写。
再次考虑数据库的例子。假设内核使用优先级调度算法，井提供了一条可供进程设置（并改变）优先级的系统调用。这样，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。
==在这里，调度机制位于内核，而调度策略则由用户进程决定。策略与机制分离是一种关键性思路==

---
# 第三章 死锁管理

## 3.1 地址空间
把物理地址暴露给进程会带来这两个问题：
1. 用户程序可以寻址内存每个字节，就很容易破坏操作系统。
2. 使用这种模型，想要同时运行多个程序是很困难的。
### 3.1.1 地址空间的概念
**地址空间是一个进程可用于寻址内存的一套地址集合。** 每个进程都有一个自己的地址空间，井且这个地址空间独立于其他进程的地址空间。
## 3.2虚拟内存
摇要运行的程序往往大到内存无法容纳，而且必然需要系统能够支持多个程序同时运行，即使内存可以满足其中单独一个程序的需要，总体来吞它们仍然超出了内存大小。

**虚拟内存的基本思想是：**
每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页或页面 。每一页有连续的地址范围。这些页被映射到物理内存，但并**不是所有的页都必须在内存中才能运行程序**。当程序引用到一部分在==物理内存中的地址空间时，由硬件立刻执行必要的映射==。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令(**缺页中断**)。
### 3.2.1 分页
大部分虚拟内存系统中都是用一种称为**分页**的技术。
当程序执行指令
`MOV REG 1000`
它把地址为 1000的内存单元的内容复制到REG中（或者相反，这取决于计算机的型号）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。
由程序产生的这些地址称为**虚拟地址**, 它们构成了一个虚拟地址空间。在没有虚拟内存的计算机上系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存总线上，而**在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到 内存管理单元 (MMU),  MMU把虚拟地址映射为物理内存地址**。
虚拟地址空间按照**固定大小**划分成被称为**页面** (page) 的若干单元。在**物理内存中对应的单元称为页框** (page frame) 。页面和页框的大小通常是一样的，

**MMU注意到该页面没有被映射**，并是使CPU陷入到操作系统，这个陷阱称为缺页中断或缺页错误 (page fault)。操作系统找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令(**先把页框内容放入磁盘，即回收，然后在把需要的页放入页框**)。

### 3.2.2 页表
虚拟地址到物理地址的映射可以概括如下：虚拟地址被分成**虚拟页号（高位部分）和偏移址（低位部分）两部分**。
虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号（如果有的话）。==然后把页框号拼接到偏移址的高位，以替换掉虚拟页号，形成送往内存的物理地址。==

### 3.3.3 针对大内存的页表--多级页表