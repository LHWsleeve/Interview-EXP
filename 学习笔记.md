### 1.Java 面向对象编程三大特性: 封装 继承 多态

#### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

#### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下 3 点请记住：**

子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，_只是拥有_。
子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
子类可以用自己的方式实现父类的方法。（以后介绍）。

#### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

**<font color="blue" size="4">在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</font>**

### 2.String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

#### 可变性

简单的来说：`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。而 `StringBuilder`与 ` StringBuffer ``都继承自 AbstractStringBuilder ` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。

**_注意:_** JDK11 中我发现所有 String\*\*类型都是由字节(`byte[]`)数组保存而不是字符(`char[]`)数组

#### 线程安全性

String 由 final 修饰，是不可变对象，是线程安全的。

StringBuffer 的方法由`synchronized`修饰(对方法加了同步锁或对调用的方法加了同步锁)，所以线程安全

StringBuilder 没有对方法加锁，所以非线程安全。

#### 性能

每次对 String**改变**的时候，会生成一个新的 String 对象，然后将指针纸箱新的对象。

StringBuffer 和 StringBuilder 每次改变时对会对**对象本身**进行操作，不会生成新的对象。
这二者相比后者只比前者性能高 10-15%，但存在线程不安全的风险。

#### 使用总结

少量数据：String；
单线程大量数据：StringBuilder；
多线程大连数据：StringBuffer；

### 3.自动装箱和拆箱

装箱：基本类型用他们对应的引用类型包装起来(变成包装类)
拆箱：将包装类型转换为基本数据类型

### 4.在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。
即：如果子类继承与父类，在子类实例化前先实例化父类。若子类中没有用`super()`方法调用父类的有参构造器，JVM 自动调用无参构造器。无参构造器就是为了防止报错。

注：我在手动实现 JDBC 时，数据库和 POJO 的映射关系时必须要生成无参构造器。（印象）

### 5. 接口和抽象类的区别是什么？

1. 接口的方法默认是 `public`，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了 `static`、`final` 变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但**只能实现一个抽象类**。接口自己本身可以通过 `extends` 关键字扩展多个接口。
4. 接口方法默认修饰符是`public`，抽象方法可以有`public、protected 和 default` 这些修饰符 **<font color="red">_（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）</font>_**。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

**备注：**

```markdown
1. 在 jdk 7 或更早版本中，接口里面只能有常量、变量和抽象方法。这些接口方法必须由选择实现接口的类实现。
2. jdk8 的时候接口可以有默认方法和静态方法功能。---静态方法可以直接用接口名调用。**实现类和实现是不可以调用的**。
3. 如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写
4. Jdk 9 在接口中引入了私有方法和私有静态方法。
5. 关于抽象类
   JDK 1.8 以前，抽象类的方法默认访问权限为 protected
   JDK 1.8 时，抽象类的方法默认访问权限变为 default
   关于接口
   JDK 1.8 以前，接口中的方法必须是 public 的
   JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的
   JDK 1.9 时，接口中的方法可以是 private 的
```

### 6. 成员变量与局部变量的区别有哪些？

1. 从**语法形式**上看:`成员变量`是属于类的(**类开始定义的变量，经常被我认为是全局变量，实际上 Java 不存在全局变量，static 可以冒充一下**)，而`局部变量`是在方法中定义的变量或是方法的参数；`成员变量`可以被 `public,private,static` 等访问控制符所修饰，而`局部变量`不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。
2. 变量在内存中的**存储方式**来看:如果`成员变量`是使用`static`修饰的，那么这个成员变量是属于类的(**此时冒充全局变量**)，如果没有使用 static 修饰，这个成员变量是属于`实例`的。而**对象存在于堆内存，局部变量则存在于栈内存**。<font color="red" size="5">重要</font>
3. 从变量在内存中的**生存时间**上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. **成员变量如果没有被赋初值**:则会自动以类型的默认值而赋值（一种情况例外:被 `final`修饰的成员变量也必须显式地赋值(而且还是大写)），而**局部变量则不会自动赋值**。

### 7.创建一个对象用什么运算符?对象实体与对象引用有何不同?

new 运算符，new 创建对象实例（**对象实例在堆内存中**），对象引用指向对象实例（**对象引用存放在栈内存中**）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

### 8.
