### 1.Java 面向对象编程三大特性: 封装 继承 多态

#### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

#### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下 3 点请记住：**

子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，_只是拥有_。
子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
子类可以用自己的方式实现父类的方法。（以后介绍）。

#### 多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

**<font color="blue" size="4">在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</font>**

### 2.String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

#### 可变性

简单的来说：`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。而 `StringBuilder`与 ` StringBuffer ``都继承自 AbstractStringBuilder ` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。

当创建 String 类型的对象时，虚拟机会在常量池中查找有没有**已经存在的值和要创建的值相同的对象**，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

**_注意:_** JDK11 中我发现所有 String\*\*类型都是由字节(`byte[]`)数组保存而不是字符(`char[]`)数组

#### 线程安全性

String 由 final 修饰，是不可变对象，是线程安全的。

StringBuffer 的方法由`synchronized`修饰(对方法加了同步锁或对调用的方法加了同步锁)，所以线程安全

StringBuilder 没有对方法加锁，所以非线程安全。

#### 性能

每次对 String**改变**的时候，会生成一个新的 String 对象，然后将指针纸箱新的对象。

StringBuffer 和 StringBuilder 每次改变时对会对**对象本身**进行操作，不会生成新的对象。
这二者相比后者只比前者性能高 10-15%，但存在线程不安全的风险。

#### 使用总结

少量数据：String；
单线程大量数据：StringBuilder；
多线程大连数据：StringBuffer；

### 3.自动装箱和拆箱

装箱：基本类型用他们对应的引用类型包装起来(变成包装类)
拆箱：将包装类型转换为基本数据类型

### 4.在 Java 中定义一个不做事且没有参数的构造方法的作用

Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。
即：如果子类继承与父类，在子类实例化前先实例化父类。若子类中没有用`super()`方法调用父类的有参构造器，JVM 自动调用无参构造器。无参构造器就是为了防止报错。

注：我在手动实现 JDBC 时，数据库和 POJO 的映射关系时必须要生成无参构造器。（印象）

### 5. 接口和抽象类的区别是什么？

1. 接口的方法默认是 `public`，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了 `static`、`final` 变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但**只能实现一个抽象类**。接口自己本身可以通过 `extends` 关键字扩展多个接口。
4. 接口方法默认修饰符是`public`，抽象方法可以有`public、protected 和 default` 这些修饰符 **<font color="red">_（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）</font>_**。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

**备注：**

```markdown
1. 在 jdk 7 或更早版本中，接口里面只能有常量、变量和抽象方法。这些接口方法必须由选择实现接口的类实现。
2. jdk8 的时候接口可以有默认方法和静态方法功能。---静态方法可以直接用接口名调用。**实现类和实现是不可以调用的**。
3. 如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写
4. Jdk 9 在接口中引入了私有方法和私有静态方法。
5. 关于抽象类
   JDK 1.8 以前，抽象类的方法默认访问权限为 protected
   JDK 1.8 时，抽象类的方法默认访问权限变为 default
   关于接口
   JDK 1.8 以前，接口中的方法必须是 public 的
   JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的
   JDK 1.9 时，接口中的方法可以是 private 的
```

### 6. 成员变量与局部变量的区别有哪些？

1. 从**语法形式**上看:`成员变量`是属于类的(**类开始定义的变量，经常被我认为是全局变量，实际上 Java 不存在全局变量，static 可以冒充一下**)，而`局部变量`是在方法中定义的变量或是方法的参数；`成员变量`可以被 `public,private,static` 等访问控制符所修饰，而`局部变量`不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。
2. 变量在内存中的**存储方式**来看:如果`成员变量`是使用`static`修饰的，那么这个成员变量是属于类的(**此时冒充全局变量**)，如果没有使用 static 修饰，这个成员变量是属于`实例`的。而**对象存在于堆内存，局部变量则存在于栈内存**。<font color="red" size="5">重要</font>
3. 从变量在内存中的**生存时间**上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. **成员变量如果没有被赋初值**:则会自动以类型的默认值而赋值（一种情况例外:被 `final`修饰的成员变量也必须显式地赋值(而且还是大写)），而**局部变量则不会自动赋值**。

### 7.创建一个对象用什么运算符?对象实体与对象引用有何不同?

new 运算符，new 创建对象实例（**对象实例在堆内存中**），对象引用指向对象实例（**对象引用存放在栈内存中**）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

### 8.静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。

2. **静态方法**在访问**本类**的成员时，只允许访问静态成员（即静态成员变量和静态方法），而**不允许访问实例成员变量和实例方法**；实例方法则无此限制。
   **原因：** 静态方法随着类的创建而创建，实例成员变量和实例方法此时可能并未创建。

### 9.对象的相等(equals)与指向他们的引用(==)相等,两者有什么不同?

<font color="blue" size="4">对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</font>

#### 9.1 ：<font color="red" size="4">比较:</font>

**== :** 它的作用是判断两个**对象的地址**是不是相等。即，判断两个对象是不是同一个对象(基本数据类型`==`比较的是值，引用数据类型`==`比较的是内存地址,即对象存放的地址是不是一样)。

**equals() :** 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，对象值得比较。对于没有重写过 equals()的对象，本质和`==`没区别。
  **注意：**_String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。_

```java
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

- 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

#### 9.2 hashCode 与 equals(重要)

**hashCode（）：** hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个`int`整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。
`hashCode()` 定义在 `JDK` 的 `Object.java` 中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。

**以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：** 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashcode` 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同`hashcode`值的对象，这时会调用 equals()方法来检查`hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。
<font color="red">HashSet 计算对象的 hashcode 值--->若哈希值相同，则 equals 比较，不同则插入，相同则舍弃</font>

**<font color="red">hashcode（）和 equals（）的关系：</font>**
（1）如果不创建“类对应的散列表的话”（就是当我们不会把一个类放到在 `HashSet, Hashtable, HashMap`这种底层实现是以 `hashcode` 来去定位存储位置的话），如果不是这种情况下的话，此时这个类的 `hashcode（）和 equals（）`是没有一点关系的

（2）如果恰好用到了上面所说的“创建了类对应的散列表的话”，那么也就是你把这个类作为 key 来去存储其他的 value 的话，这种情况下是可以进行比较的

如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。
如果两个对象 hashCode()相等，它们并不一定相等。
因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。**然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。**（若要判断两个对象是否相等，除了要覆盖 equals()之外，也要覆盖 hashCode()函数。否则，equals()无效。 ）**即，哈希值相等可能是因为处理哈希冲突造成的**
<font color="red" size="5">equal 相等-->hashCode()相等，反之不成立</font>

#### 9.3 hashCode（）与 equals（）的相关规定

- 如果两个对象相等，则 `hashcode` 一定也是相同的
- 两个对象相等,对两个对象分别调用 `equals` 方法都返回`true`
- 两个对象有相同的 `hashcode`值，它们也不一定是相等的
- 因此，`equals` 方法被覆盖过，则 `hashCode` 方法也必须被覆盖
- `hashCode()` 的默认行为是对堆上的对象产生**独特值**。如果没有重写 `hashCode()`，则该 `class` 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据---如果类需要放进类似`HashMap` 之类的基于哈希表来实现的容器中并作为 `key` 时，就有必要覆盖 `hashCode`方法，按照我们自定的规则来得到一个矩形对象的 `hash`值。（不指定，一般是通过将该对象的内部地址转换成一个整数来实现的））

### 10.为什么 Java 中只有值传递？

按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。

Java 程序设计语言**总是采用按值调用**。也就是说，方法得到的是所有参数值(或引用)的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容(可以修改拷贝的引用所指向的对象的内容)。
example:基本类型

```java
public static void main(String[] args) {
    int num1 = 10;
    int num2 = 20;

    swap(num1, num2);

    System.out.println("num1 = " + num1);
    System.out.println("num2 = " + num2);
}

public static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;

    System.out.println("a = " + a);
    System.out.println("b = " + b);
}
显然：
a = 20
b = 10
num1 = 10
num2 = 20
```

example2：对象

```java
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5 };
        System.out.println(arr[0]);
        change(arr);
        System.out.println(arr[0]);
    }

    public static void change(int[] array) {
        // 将数组的第一个元素变为0
        array[0] = 0;
    }
显然：
1
0
```

此时似乎是引用调用，实际上并不是。传入的`array`是`arr`的一个**拷贝**（浅拷贝还是深拷贝，需要验证），因为拷贝的引用和原引用指向同一个对象所以可以修改对象内的内容。
Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

下面再总结一下 Java 中方法参数的使用情况：

- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。
- 一个方法可以改变一个对象参数的状态。
- 一个方法不能让对象参数引用一个新的对象。

### 11.简述线程、程序、进程的基本概念

- **_进程_** 是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。**线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响**。从另一角度来说，进程属于操作系统的范畴，主要是**同一段时间**内，可以同时执行一个以上的程序，而线程则是在**同一程序**内几乎同时执行一个以上的程序段。
- **_线程_** 与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程 **_共享同一块内存空间和一组系统资源(所以线程安全很重要)_**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为**轻量级进程**。

- **_程序_** 是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

#### 11.1 线程有哪些基本状态?

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：
![线程状态](assserts/12.png)

Java 线程状态变迁图：
![Java 线程状态变迁](assserts/Java线程状态变迁.png)
