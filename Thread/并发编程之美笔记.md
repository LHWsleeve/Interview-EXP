## Java并法包中并发队列的原理剖析

### ConcurrentLinkedQueue-无界非阻塞队列
无界非阻塞队列，底层数据结构使用单向链表实现，对于入队和出队操作使用CAS来实现线程安全。
两个volatile累心那个的Node节点分别指向队首和队尾节点。默认头尾节点都是指向item为null的哨兵节点。新元素使用CAS方式保证插入队列末尾，出队时从队列头部获取一个元素的原子性。
**总结：**  底层使用单向链表数据结构来保存队列元素，每个元素被包装成一个Node节点。队列是靠头、尾节点来维护的，创建队列时头尾节点指向一个item为null的哨兵节点。第一次执行peek或者操作。
### LinkedBlockingQueue 独占锁实现的阻塞队列

默认队列容量是 0x7fffffff，用户也可以自己指定容量，某种程度上可以说是**有界阻塞队列**。
**小结**：该结构内部是通过单向链表实现的，使用头尾节点来进行入队和出队的操作，也就是入队操作都是对尾节点进行操作，出队操作都是对头节点进行操作。对头尾节点分别使用了独占锁(ReentrantLock)来保证原子性，所以出对和入队操作是可以同时进行的。林我改对头尾节点的独占锁都配备了一个条件队列，用来存放被阻塞的线程，并结合出队入队操作，实现了一个生产者消费者模型。
==同时这是newFixed和newSingle创建线程池的默认workqueue，允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM==

### ArrayBlockingQueue 有界数组阻塞队列

该结构通过使用全局独占锁(ReentrantLock)实现了同时只能有一个线程入队或者出队操作，这个锁粒度比较大，有点累俗语在方法上添加 syn 的意思。其中 offer 和 poll 操作通过简单的加锁进行入队和出队操作，而 put.take 操作则使用条件变量实现了，如果队列满则等待，如果队列空则等待，然后分别出队和入队操作中发送信号激活等待线程实现同步。另外相比 LinkedBlockingQueue，该结构的 size 操作结果是精确的，因为计算前加了全局锁。

### PriorityBlockingQueue 带优先级无界阻塞

带优先级的无界阻塞队列，每次出队都返回优先级最高或者最低的元素。内部使用堆来实现，所以直接便利并不保证有序，这个数组是可以扩容的，默认队列容量 11。当当前元素个数》+最大容量时候会通过 CAS 算法扩容，出队时始终保持出对的元素是堆的根节点。
类似于 ArrayBlockingQueue，内部使用一个独占锁来控制同时只有一个线程可以进行出队和入队操作。另外本结构只使用了一个 notEmpty 条件变量，没有使用 notFull，这是因为这是一个无界队列，执行 put 操作时不会处于 await，所以也不需要被唤醒。
本结构，有一个 tryGrow 方法，作用扩容。并且扩容前先释放锁，然后使用 CAS 控制只有一个线程可以扩容成功。==其实也可以不释放锁，但是整个扩容期间一直持有锁的话，其他线程这时候无法出队入队操作，大大降低了并发效率。为了提高性能，使用 CAS 控制只有一个线程可以扩容那个，并在扩容前释放锁，让其他线程可以出队入队操作。==

### DelayQueue 无界阻塞延迟队列

这是一个无界阻塞延迟队列，队列中每个元素都有一个过期时间，党对列获取元素时，只有国企原素材可以出队列。
内部使用优先级队列存放数据，使用 ReentrantLock 实现线程同步。==另外队列里面的元素必须是实现了 Delayed 接口的并且重写了`getDelay()`和`compareTo()`方法的实例前者判断是否过期，后者作为优先级队列的自定义规则。==

